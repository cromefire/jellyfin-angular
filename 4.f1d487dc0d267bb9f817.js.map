{"version":3,"sources":["./src/app/shell/shell.module.ts","./node_modules/rxjs/_esm2015/internal/operators/skip.js.pre-build-optimizer.js","./node_modules/@angular/cdk/esm2015/layout.js.pre-build-optimizer.js","./node_modules/@angular/cdk/esm2015/overlay.js.pre-build-optimizer.js","./node_modules/@angular/material/esm2015/tooltip.js.pre-build-optimizer.js","./node_modules/@angular/material/esm2015/progress-bar.js.pre-build-optimizer.js","./node_modules/@angular/material/progress-bar/typings/index.ngfactory.js.pre-build-optimizer.js","./node_modules/@angular/material/progress-bar/typings/index.d.ts.MatProgressBar.html","./node_modules/rxjs/_esm2015/internal/operators/sampleTime.js.pre-build-optimizer.js","./node_modules/ngx-infinite-scroll/modules/ngx-infinite-scroll.js.pre-build-optimizer.js","./src/app/common/slider/slider.component.ts","./src/app/common/slider/slider.component.ngfactory.js.pre-build-optimizer.js","./src/app/common/slider/slider.component.scss.shim.ngstyle.js.pre-build-optimizer.js","./src/app/common/slider/slider.component.html","./src/app/utils/index.ts","./src/app/library/home/home.component.ts","./src/app/library/home/home.component.ngfactory.js.pre-build-optimizer.js","./src/app/library/home/home.component.scss.shim.ngstyle.js.pre-build-optimizer.js","./src/app/library/home/home.component.html","./src/app/library/movies/movies.component.ts","./src/app/library/movies/movies.component.ngfactory.js.pre-build-optimizer.js","./src/app/library/movies/movies.component.scss.shim.ngstyle.js.pre-build-optimizer.js","./src/app/library/movies/movies.component.html","./node_modules/@angular/material/tooltip/typings/index.ngfactory.js.pre-build-optimizer.js","./node_modules/@angular/material/tooltip/typings/index.d.ts.TooltipComponent.html","./src/app/shell/shell-routing.module.ts","./src/app/shell/shell.module.ngfactory.js.pre-build-optimizer.js"],"names":["ShellModule","SkipOperator","total","this","subscriber","source","subscribe","Subscriber","destination","super","count","x","next","mediaQueriesForWebkitCompatibility","Set","mediaQueryStyleNode","MediaMatcher","_platform","_matchMedia","isBrowser","window","matchMedia","bind","noopMatchMedia","query","WEBKIT","has","document","createElement","setAttribute","appendChild","sheet","insertRule","add","e","console","error","createEmptyStyleRule","ngInjectableDef","factory","token","providedIn","matches","media","addListener","removeListener","BreakpointObserver","_mediaMatcher","_zone","_queries","Map","_destroySubject","Subject","complete","value","splitQueries","some","mediaQuery","_registerQuery","mql","observables","map","observable","stateObservable","combineLatest","concat","pipe","take","lift","debounceTime","breakpointStates","response","breakpoints","forEach","state","get","output","Observable","observer","handler","run","startWith","nextMql","takeUntil","set","queries","split","reduce","a1","a2","trim","Breakpoints","XSmall","Small","Medium","Large","XLarge","Handset","Tablet","Web","HandsetPortrait","TabletPortrait","WebPortrait","HandsetLandscape","TabletLandscape","WebLandscape","_viewportRuler","_previousHTMLStyles","top","left","_isEnabled","_document","_canBeEnabled","root","_previousScrollPosition","getViewportScrollPosition","style","classList","html","htmlStyle","bodyStyle","previousHtmlScrollBehavior","scrollBehavior","previousBodyScrollBehavior","remove","scroll","contains","body","viewport","getViewportSize","scrollHeight","height","scrollWidth","width","getMatScrollStrategyAlreadyAttachedError","Error","CloseScrollStrategy","_scrollDispatcher","_ngZone","_config","_scrollSubscription","_detach","disable","_overlayRef","hasAttached","detach","overlayRef","stream","scrolled","threshold","_initialScrollPosition","scrollPosition","Math","abs","updatePosition","unsubscribe","NoopScrollStrategy","isElementScrolledOutsideView","element","scrollContainers","containerBounds","bottom","right","isElementClippedByScrolling","scrollContainerRect","RepositionScrollStrategy","scrollThrottle","autoClose","overlayRect","overlayElement","getBoundingClientRect","ScrollStrategyOptions","noop","close","config","block","reposition","OverlayConfig","scrollStrategy","panelClass","hasBackdrop","backdropClass","disposeOnNavigation","configKeys","Object","keys","key","undefined","ConnectionPositionPair","origin","overlay","offsetX","offsetY","originX","originY","overlayX","overlayY","ConnectedOverlayPositionChange","connectionPair","scrollableViewProperties","validateVerticalPosition","property","validateHorizontalPosition","OverlayKeyboardDispatcher","_attachedOverlays","_keydownListener","event","overlays","i","length","_keydownEventSubscriptions","_keydownEvents","_isAttached","addEventListener","push","index","indexOf","splice","removeEventListener","OverlayContainer","_containerElement","parentNode","removeChild","_createContainer","previousContainers","getElementsByClassName","container","_portalOutlet","_host","_pane","_keyboardDispatcher","_location","_backdropElement","_backdropClick","_attachments","_detachments","_locationChanges","Subscription","EMPTY","_backdropClickHandler","_keydownEventsObservable","subscription","_scrollStrategy","attach","_positionStrategy","positionStrategy","portal","attachResult","parentElement","_previousHostParent","_updateStackingOrder","_updateElementSize","_updateElementDirection","enable","onStable","asObservable","_togglePointerEvents","_attachBackdrop","_toggleClasses","dispose","detachBackdrop","detachmentResult","_detachContentWhenStable","isAttached","_disposeScrollStrategy","apply","strategy","sizeConfig","assign","dir","direction","classes","getDirection","minWidth","minHeight","maxWidth","maxHeight","enablePointer","pointerEvents","insertBefore","requestAnimationFrame","runOutsideAngular","nextSibling","timeoutId","backdropToDetach","finishDetach","clearTimeout","setTimeout","cssClasses","isAdd","cssClass","merge","children","boundingBoxClass","connectedTo","_overlayContainer","_lastBoundingBoxSize","_isPushed","_canPush","_growAfterOpen","_hasFlexibleDimensions","_positionLocked","_viewportMargin","_scrollables","_preferredPositions","_positionChanges","_resizeSubscription","_offsetX","_offsetY","_appliedPanelClasses","positionChanges","setOrigin","_validatePositions","hostElement","_boundingBox","_isDisposed","_isInitialRender","_lastPosition","change","reapplyLastPosition","_clearPanelClasses","_resetOverlayElementStyles","_resetBoundingBoxStyles","_viewportRect","_getNarrowedViewportRect","_originRect","_getOriginRect","_overlayRect","originRect","viewportRect","flexibleFits","fallback","pos","originPoint","_getOriginPoint","overlayPoint","_getOverlayPoint","overlayFit","_getOverlayFit","isCompletelyWithinViewport","_applyPosition","_canFitWithFlexibleDimensions","position","boundingBoxRect","_calculateBoundingBoxRect","visibleArea","bestFit","bestScore","fit","score","weight","_previousPushAmount","extendStyles","alignItems","justifyContent","lastPosition","scrollables","positions","margin","flexibleDimensions","growAfterOpen","canPush","isLocked","_origin","offset","selector","_transformOriginSelector","y","startX","_isRtl","endX","overlayStartX","overlayStartY","point","_getOffset","topOverflow","bottomOverflow","visibleWidth","_subtractOverflows","visibleHeight","fitsInViewportVertically","fitsInViewportHorizontally","availableHeight","availableWidth","getConfig","horizontalFit","start","overflowRight","max","overflowBottom","overflowTop","overflowLeft","pushX","pushY","_setTransformOrigin","_setOverlayElementStyles","_setBoundingBoxStyles","_addPanelClasses","observers","_getScrollVisibility","changeEvent","elements","querySelectorAll","xOrigin","yOrigin","transformOrigin","isRtl","smallestDistanceToViewportEdge","min","previousHeight","previousWidth","styles","_hasExactPosition","transform","_getExactOverlayY","_getExactOverlayX","transformString","_pushOverlayOnScreen","virtualKeyboardOffset","getContainerElement","clientHeight","horizontalStyleProperty","clientWidth","originBounds","overlayBounds","scrollContainerBounds","scrollable","getElementRef","nativeElement","isOriginClipped","isOriginOutsideView","isOverlayClipped","isOverlayOutsideView","overflows","currentValue","currentOverflow","axis","pair","HTMLElement","dest","hasOwnProperty","ConnectedPositionStrategy","originPos","overlayPos","viewportRuler","platform","overlayContainer","withFlexibleDimensions","withPush","withViewportMargin","withFallbackPosition","_direction","setDirection","withScrollableContainers","withPositions","withDefaultOffsetX","withDefaultOffsetY","withLockedPosition","slice","wrapperClass","GlobalPositionStrategy","_cssPosition","_topOffset","_bottomOffset","_leftOffset","_rightOffset","_alignItems","_justifyContent","_width","_height","updateSize","parentStyles","marginLeft","marginTop","marginBottom","marginRight","parent","OverlayPositionBuilder","elementRef","nextUniqueId","scrollStrategies","_componentFactoryResolver","_positionBuilder","_injector","_directionality","host","_createHostElement","pane","_createPaneElement","portalOutlet","_createPortalOutlet","overlayConfig","id","_appRef","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY","OverlayModule","SCROLL_THROTTLE_MS","TOOLTIP_PANEL_CLASS","getMatTooltipInvalidPositionError","MAT_TOOLTIP_SCROLL_STRATEGY","MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY","MAT_TOOLTIP_DEFAULT_OPTIONS","showDelay","hideDelay","touchendHideDelay","_overlay","_elementRef","_viewContainerRef","_ariaDescriber","_focusMonitor","_dir","_defaultOptions","hammerLoader","_position","_disabled","_message","_manualListeners","_destroyed","hasGestures","Hammer","IOS","ANDROID","show","hide","listener","monitor","_updatePosition","_tooltipInstance","removeDescription","_isTooltipVisible","_updateTooltipMessage","Promise","resolve","then","describe","message","_tooltipClass","_setTooltipClass","elementStyle","nodeName","webkitUserSelect","userSelect","msUserSelect","draggable","webkitUserDrag","clear","stopMonitoring","delay","disabled","_showTimeoutId","_hideTimeoutId","_createOverlay","_portal","instance","afterHidden","isVisible","keyCode","preventDefault","stopPropagation","scrollableAncestors","getAncestorScrollContainers","flexibleConnectedTo","withTransformOriginOn","create","detachments","_getOrigin","_getOverlayPosition","main","isLtr","originPosition","_invertPosition","overlayPosition","_markForCheck","onMicrotaskEmpty","tooltipClass","_changeDetectorRef","_breakpointObserver","_visibility","_closeOnInteraction","_onHide","_isHandset","observe","toState","markForCheck","MatTooltipModule","MatProgressBarBase","_MatProgressBarMixinBase","MAT_PROGRESS_BAR_LOCATION","location","getPathname","pathname","search","progressbarId","_animationMode","_isNoopAnimation","_value","_bufferValue","animationEnd","_animationEndSubscription","mode","path","_rectangleFillValue","v","clamp","_emitAnimationEnd","bufferValue","_primaryValueBar","fromEvent","filter","target","MatProgressBarModule","RenderType_MatProgressBar","encapsulation","data","View_MatProgressBar_0","_l","SampleTimeOperator","period","scheduler","hasValue","schedule","dispatchNotification","lastValue","notifyNext","resolveContainerElement","scrollWindow","defaultElement","fromRoot","hasWindow","documentElement","customRoot","querySelector","findElement","inputPropChanged","prop","firstChange","VerticalProps","offsetHeight","pageYOffset","offsetTop","scrollTop","HorizontalProps","AxisResolver","vertical","propsMap","isElementWindow","windowElement","obj","prototype","toString","call","includes","getDocumentElement","isContainerWindow","calculatePoints","resolver","isWindow","offsetHeightKey","clientHeightKey","extractHeightPropKeys","getElementHeight","extractHeightForElement","getElementPageYOffset","nativeElementHeight","totalToScroll","elem","topKey","getElementOffsetTop","calculatePointsForWindow","scrollTopKey","scrollHeightKey","calculatePointsForElement","isNaN","docElem","pageYOffsetKey","offsetTopKey","ownerDocument","defaultView","shouldFireScrollEvent","distance","scrollingDown","remaining","containerBreakpoint","scrolledUntilNow","down","up","ScrollState","lastScrollPosition","lastTotalToScroll","triggered","updateScrollPosition","updateTotalToScroll","isScrollingDown","InfiniteScrollActions","DOWN","UP","toInfiniteScrollAction","scrollDown","stats","currentScrollPosition","type","payload","zone","scrolledUp","infiniteScrollDistance","infiniteScrollUpDistance","infiniteScrollThrottle","infiniteScrollDisabled","infiniteScrollContainer","immediateCheck","horizontal","alwaysCallback","setup","containerChanged","disabledChanged","distanceChanged","shouldSetup","destroyScroller","disposeScroller","scrollContainer","createResolverWithContainer","createResolver","scrollState","upDistance","downDistance","options","obs","throttle","sampleTime","attachScrollEvent","mergeMap","of","positionStats","fire","isScrollingDownwards","getScrollStats","toInfiniteScrollParams","tap","updateScroll","isTriggeredCurrentTotal","shouldTriggerEvents","isTriggeredScroll","updateTriggeredFlag","createScroller","handleOnScroll","emit","InfiniteScrollModule","SliderComponent","changeDetector","slider","detectChanges","log","parentRect","getClientRects","child","Array","from","reverse","scrollIntoView","behavior","RenderType_SliderComponent","View_SliderComponent_0","ad","more","assertNever","apiService","authService","router","myMedia","continueWatching","latestMovies","loaded","all","loadViews","loadStarted","loadLatest","createUrlTree","userId","resp","item","Items","tile","subtitle","Name","CollectionType","ImageTags","Primary","image","assembleUrl","Id","tag","quality","toPromise","Limit","Recursive","ImageTypeLimit","EnableImageTypes","EnableTotalRecordCount","MediaTypes","title","cut","sliceTitle","year","Date","PremiereDate","getFullYear","originalTitle","progress","UserData","PlayedPercentage","BackdropImageTags","imageType","EnableImageType","PemiereDate","space","lastIndexOf","RenderType_HomeComponent","View_HomeComponent_3","$event","View_HomeComponent_4","View_HomeComponent_2","_v","onClick","button","ctrlKey","metaKey","shiftKey","routerLink","View_HomeComponent_6","View_HomeComponent_7","View_HomeComponent_5","en","_handleKeydown","_handleTouchend","View_HomeComponent_9","View_HomeComponent_10","View_HomeComponent_8","View_HomeComponent_1","View_HomeComponent_11","View_HomeComponent_0","View_HomeComponent_Host_0","_ck","HomeComponentNgFactory","MoviesComponent","RenderType_MoviesComponent","View_MoviesComponent_0","View_MoviesComponent_Host_0","MoviesComponentNgFactory","RenderType_TooltipComponent","name","definitions","opacity","expr","animation","steps","timings","View_TooltipComponent_0","_co","_animationStart","_animationDone","View_TooltipComponent_Host_0","_handleBodyInteraction","TooltipComponentNgFactory","ShellRoutingModule","ShellModuleNgFactory","component"],"mappings":"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","file":"4.f1d487dc0d267bb9f817.js","sourcesContent":["import { CommonModule } from \"@angular/common\";\nimport { NgModule } from \"@angular/core\";\nimport {\n    MatButtonModule,\n    MatCardModule,\n    MatIconModule,\n    MatProgressBarModule,\n    MatProgressSpinnerModule,\n    MatRippleModule,\n    MatTooltipModule\n} from \"@angular/material\";\nimport { InfiniteScrollModule } from \"ngx-infinite-scroll\";\n\nimport { HomeComponent } from \"../library/home/home.component\";\nimport { SliderComponent } from \"../common/slider/slider.component\";\nimport { MoviesComponent } from \"../library/movies/movies.component\";\nimport { ShellRoutingModule } from \"./shell-routing.module\";\n\n@NgModule({\n    declarations: [HomeComponent, SliderComponent, MoviesComponent],\n    imports: [\n        CommonModule,\n        ShellRoutingModule,\n        MatCardModule,\n        MatButtonModule,\n        MatRippleModule,\n        MatProgressSpinnerModule,\n        InfiniteScrollModule,\n        MatTooltipModule,\n        MatProgressBarModule,\n        MatIconModule\n    ],\n    bootstrap: []\n})\nexport class ShellModule {}\n","import { Subscriber } from '../Subscriber';\nexport function skip(count) {\n    return (source) => source.lift(new SkipOperator(count));\n}\nclass SkipOperator {\n    constructor(total) {\n        this.total = total;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new SkipSubscriber(subscriber, this.total));\n    }\n}\nclass SkipSubscriber extends Subscriber {\n    constructor(destination, total) {\n        super(destination);\n        this.total = total;\n        this.count = 0;\n    }\n    _next(x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    }\n}\n//# sourceMappingURL=skip.js.map","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { NgModule, Injectable, NgZone, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\nimport { Platform } from '@angular/cdk/platform';\nimport { combineLatest, concat, Observable, Subject } from 'rxjs';\nimport { debounceTime, map, skip, startWith, take, takeUntil } from 'rxjs/operators';\nimport { coerceArray } from '@angular/cdk/coercion';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass LayoutModule {\n}\nLayoutModule.decorators = [\n    { type: NgModule, args: [{},] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Global registry for all dynamically-created, injected media queries.\n * @type {?}\n */\nconst mediaQueriesForWebkitCompatibility = new Set();\n/**\n * Style tag that holds all of the dynamically-created media queries.\n * @type {?}\n */\nlet mediaQueryStyleNode;\n/**\n * A utility for calling matchMedia queries.\n */\nclass MediaMatcher {\n    /**\n     * @param {?} _platform\n     */\n    constructor(_platform) {\n        this._platform = _platform;\n        this._matchMedia = this._platform.isBrowser && window.matchMedia ?\n            // matchMedia is bound to the window scope intentionally as it is an illegal invocation to\n            // call it from a different scope.\n            window.matchMedia.bind(window) :\n            noopMatchMedia;\n    }\n    /**\n     * Evaluates the given media query and returns the native MediaQueryList from which results\n     * can be retrieved.\n     * Confirms the layout engine will trigger for the selector query provided and returns the\n     * MediaQueryList for the query provided.\n     * @param {?} query\n     * @return {?}\n     */\n    matchMedia(query) {\n        if (this._platform.WEBKIT) {\n            createEmptyStyleRule(query);\n        }\n        return this._matchMedia(query);\n    }\n}\nMediaMatcher.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nMediaMatcher.ctorParameters = () => [\n    { type: Platform }\n];\n/** @nocollapse */ MediaMatcher.ngInjectableDef = ɵɵdefineInjectable({ factory: function MediaMatcher_Factory() { return new MediaMatcher(ɵɵinject(Platform)); }, token: MediaMatcher, providedIn: \"root\" });\n/**\n * For Webkit engines that only trigger the MediaQueryListListener when\n * there is at least one CSS selector for the respective media query.\n * @param {?} query\n * @return {?}\n */\nfunction createEmptyStyleRule(query) {\n    if (mediaQueriesForWebkitCompatibility.has(query)) {\n        return;\n    }\n    try {\n        if (!mediaQueryStyleNode) {\n            mediaQueryStyleNode = document.createElement('style');\n            mediaQueryStyleNode.setAttribute('type', 'text/css');\n            (/** @type {?} */ (document.head)).appendChild(mediaQueryStyleNode);\n        }\n        if (mediaQueryStyleNode.sheet) {\n            ((/** @type {?} */ (mediaQueryStyleNode.sheet)))\n                .insertRule(`@media ${query} {.fx-query-test{ }}`, 0);\n            mediaQueriesForWebkitCompatibility.add(query);\n        }\n    }\n    catch (e) {\n        console.error(e);\n    }\n}\n/**\n * No-op matchMedia replacement for non-browser platforms.\n * @param {?} query\n * @return {?}\n */\nfunction noopMatchMedia(query) {\n    // Use `as any` here to avoid adding additional necessary properties for\n    // the noop matcher.\n    return (/** @type {?} */ ({\n        matches: query === 'all' || query === '',\n        media: query,\n        addListener: (/**\n         * @return {?}\n         */\n        () => { }),\n        removeListener: (/**\n         * @return {?}\n         */\n        () => { })\n    }));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Utility for checking the matching state of \\@media queries.\n */\nclass BreakpointObserver {\n    /**\n     * @param {?} _mediaMatcher\n     * @param {?} _zone\n     */\n    constructor(_mediaMatcher, _zone) {\n        this._mediaMatcher = _mediaMatcher;\n        this._zone = _zone;\n        /**\n         * A map of all media queries currently being listened for.\n         */\n        this._queries = new Map();\n        /**\n         * A subject for all other observables to takeUntil based on.\n         */\n        this._destroySubject = new Subject();\n    }\n    /**\n     * Completes the active subject, signalling to all other observables to complete.\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._destroySubject.next();\n        this._destroySubject.complete();\n    }\n    /**\n     * Whether one or more media queries match the current viewport size.\n     * @param {?} value One or more media queries to check.\n     * @return {?} Whether any of the media queries match.\n     */\n    isMatched(value) {\n        /** @type {?} */\n        const queries = splitQueries(coerceArray(value));\n        return queries.some((/**\n         * @param {?} mediaQuery\n         * @return {?}\n         */\n        mediaQuery => this._registerQuery(mediaQuery).mql.matches));\n    }\n    /**\n     * Gets an observable of results for the given queries that will emit new results for any changes\n     * in matching of the given queries.\n     * @param {?} value One or more media queries to check.\n     * @return {?} A stream of matches for the given queries.\n     */\n    observe(value) {\n        /** @type {?} */\n        const queries = splitQueries(coerceArray(value));\n        /** @type {?} */\n        const observables = queries.map((/**\n         * @param {?} query\n         * @return {?}\n         */\n        query => this._registerQuery(query).observable));\n        /** @type {?} */\n        let stateObservable = combineLatest(observables);\n        // Emit the first state immediately, and then debounce the subsequent emissions.\n        stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));\n        return stateObservable.pipe(map((/**\n         * @param {?} breakpointStates\n         * @return {?}\n         */\n        (breakpointStates) => {\n            /** @type {?} */\n            const response = {\n                matches: false,\n                breakpoints: {},\n            };\n            breakpointStates.forEach((/**\n             * @param {?} state\n             * @return {?}\n             */\n            (state) => {\n                response.matches = response.matches || state.matches;\n                response.breakpoints[state.query] = state.matches;\n            }));\n            return response;\n        })));\n    }\n    /**\n     * Registers a specific query to be listened for.\n     * @private\n     * @param {?} query\n     * @return {?}\n     */\n    _registerQuery(query) {\n        // Only set up a new MediaQueryList if it is not already being listened for.\n        if (this._queries.has(query)) {\n            return (/** @type {?} */ (this._queries.get(query)));\n        }\n        /** @type {?} */\n        const mql = this._mediaMatcher.matchMedia(query);\n        // Create callback for match changes and add it is as a listener.\n        /** @type {?} */\n        const queryObservable = new Observable((/**\n         * @param {?} observer\n         * @return {?}\n         */\n        (observer) => {\n            // Listener callback methods are wrapped to be placed back in ngZone. Callbacks must be placed\n            // back into the zone because matchMedia is only included in Zone.js by loading the\n            // webapis-media-query.js file alongside the zone.js file.  Additionally, some browsers do not\n            // have MediaQueryList inherit from EventTarget, which causes inconsistencies in how Zone.js\n            // patches it.\n            /** @type {?} */\n            const handler = (/**\n             * @param {?} e\n             * @return {?}\n             */\n            (e) => this._zone.run((/**\n             * @return {?}\n             */\n            () => observer.next(e))));\n            mql.addListener(handler);\n            return (/**\n             * @return {?}\n             */\n            () => {\n                mql.removeListener(handler);\n            });\n        })).pipe(startWith(mql), map((/**\n         * @param {?} nextMql\n         * @return {?}\n         */\n        (nextMql) => ({ query, matches: nextMql.matches }))), takeUntil(this._destroySubject));\n        // Add the MediaQueryList to the set of queries.\n        /** @type {?} */\n        const output = { observable: queryObservable, mql };\n        this._queries.set(query, output);\n        return output;\n    }\n}\nBreakpointObserver.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nBreakpointObserver.ctorParameters = () => [\n    { type: MediaMatcher },\n    { type: NgZone }\n];\n/** @nocollapse */ BreakpointObserver.ngInjectableDef = ɵɵdefineInjectable({ factory: function BreakpointObserver_Factory() { return new BreakpointObserver(ɵɵinject(MediaMatcher), ɵɵinject(NgZone)); }, token: BreakpointObserver, providedIn: \"root\" });\n/**\n * Split each query string into separate query strings if two queries are provided as comma\n * separated.\n * @param {?} queries\n * @return {?}\n */\nfunction splitQueries(queries) {\n    return queries.map((/**\n     * @param {?} query\n     * @return {?}\n     */\n    (query) => query.split(',')))\n        .reduce((/**\n     * @param {?} a1\n     * @param {?} a2\n     * @return {?}\n     */\n    (a1, a2) => a1.concat(a2)))\n        .map((/**\n     * @param {?} query\n     * @return {?}\n     */\n    query => query.trim()));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// PascalCase is being used as Breakpoints is used like an enum.\n// tslint:disable-next-line:variable-name\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n * @type {?}\n */\nconst Breakpoints = {\n    XSmall: '(max-width: 599.99px)',\n    Small: '(min-width: 600px) and (max-width: 959.99px)',\n    Medium: '(min-width: 960px) and (max-width: 1279.99px)',\n    Large: '(min-width: 1280px) and (max-width: 1919.99px)',\n    XLarge: '(min-width: 1920px)',\n    Handset: '(max-width: 599.99px) and (orientation: portrait), ' +\n        '(max-width: 959.99px) and (orientation: landscape)',\n    Tablet: '(min-width: 600px) and (max-width: 839.99px) and (orientation: portrait), ' +\n        '(min-width: 960px) and (max-width: 1279.99px) and (orientation: landscape)',\n    Web: '(min-width: 840px) and (orientation: portrait), ' +\n        '(min-width: 1280px) and (orientation: landscape)',\n    HandsetPortrait: '(max-width: 599.99px) and (orientation: portrait)',\n    TabletPortrait: '(min-width: 600px) and (max-width: 839.99px) and (orientation: portrait)',\n    WebPortrait: '(min-width: 840px) and (orientation: portrait)',\n    HandsetLandscape: '(max-width: 959.99px) and (orientation: landscape)',\n    TabletLandscape: '(min-width: 960px) and (max-width: 1279.99px) and (orientation: landscape)',\n    WebLandscape: '(min-width: 1280px) and (orientation: landscape)',\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { LayoutModule, BreakpointObserver, Breakpoints, MediaMatcher };\n//# sourceMappingURL=layout.js.map\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { coerceCssPixelValue, coerceArray, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ScrollDispatcher, ViewportRuler, ScrollingModule, VIEWPORT_RULER_PROVIDER } from '@angular/cdk/scrolling';\nexport { ViewportRuler, VIEWPORT_RULER_PROVIDER, CdkScrollable, ScrollDispatcher } from '@angular/cdk/scrolling';\nimport { DOCUMENT, Location } from '@angular/common';\nimport { Inject, Injectable, NgZone, Optional, NgModule, SkipSelf, ApplicationRef, ComponentFactoryResolver, Injector, ElementRef, Directive, EventEmitter, InjectionToken, Input, Output, TemplateRef, ViewContainerRef, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\nimport { Observable, Subject, merge, Subscription } from 'rxjs';\nimport { take, takeUntil } from 'rxjs/operators';\nimport { Platform } from '@angular/cdk/platform';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { DomPortalOutlet, TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nclass BlockScrollStrategy {\n    /**\n     * @param {?} _viewportRuler\n     * @param {?} document\n     */\n    constructor(_viewportRuler, document) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n        this._document = document;\n    }\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    attach() { }\n    /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    enable() {\n        if (this._canBeEnabled()) {\n            /** @type {?} */\n            const root = (/** @type {?} */ (this._document.documentElement));\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);\n            root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    }\n    /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    disable() {\n        if (this._isEnabled) {\n            /** @type {?} */\n            const html = (/** @type {?} */ (this._document.documentElement));\n            /** @type {?} */\n            const body = (/** @type {?} */ (this._document.body));\n            /** @type {?} */\n            const htmlStyle = (/** @type {?} */ (html.style));\n            /** @type {?} */\n            const bodyStyle = (/** @type {?} */ (body.style));\n            /** @type {?} */\n            const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';\n            /** @type {?} */\n            const previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';\n            this._isEnabled = false;\n            htmlStyle.left = this._previousHTMLStyles.left;\n            htmlStyle.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            htmlStyle.scrollBehavior = previousHtmlScrollBehavior;\n            bodyStyle.scrollBehavior = previousBodyScrollBehavior;\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _canBeEnabled() {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        /** @type {?} */\n        const html = (/** @type {?} */ (this._document.documentElement));\n        if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        /** @type {?} */\n        const body = this._document.body;\n        /** @type {?} */\n        const viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(`Scroll strategy has already been attached.`);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nclass CloseScrollStrategy {\n    /**\n     * @param {?} _scrollDispatcher\n     * @param {?} _ngZone\n     * @param {?} _viewportRuler\n     * @param {?=} _config\n     */\n    constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._config = _config;\n        this._scrollSubscription = null;\n        /**\n         * Detaches the overlay ref and disables the scroll strategy.\n         */\n        this._detach = (/**\n         * @return {?}\n         */\n        () => {\n            this.disable();\n            if (this._overlayRef.hasAttached()) {\n                this._ngZone.run((/**\n                 * @return {?}\n                 */\n                () => this._overlayRef.detach()));\n            }\n        });\n    }\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    attach(overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    }\n    /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    enable() {\n        if (this._scrollSubscription) {\n            return;\n        }\n        /** @type {?} */\n        const stream = this._scrollDispatcher.scrolled(0);\n        if (this._config && this._config.threshold && this._config.threshold > 1) {\n            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n            this._scrollSubscription = stream.subscribe((/**\n             * @return {?}\n             */\n            () => {\n                /** @type {?} */\n                const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n                if (Math.abs(scrollPosition - this._initialScrollPosition) > (/** @type {?} */ ((/** @type {?} */ (this._config)).threshold))) {\n                    this._detach();\n                }\n                else {\n                    this._overlayRef.updatePosition();\n                }\n            }));\n        }\n        else {\n            this._scrollSubscription = stream.subscribe(this._detach);\n        }\n    }\n    /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    disable() {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    detach() {\n        this.disable();\n        this._overlayRef = (/** @type {?} */ (null));\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Scroll strategy that doesn't do anything.\n */\nclass NoopScrollStrategy {\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    enable() { }\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    disable() { }\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    attach() { }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n// TODO(jelbourn): move this to live with the rest of the scrolling code\n// TODO(jelbourn): someday replace this with IntersectionObservers\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some((/**\n     * @param {?} containerBounds\n     * @return {?}\n     */\n    containerBounds => {\n        /** @type {?} */\n        const outsideAbove = element.bottom < containerBounds.top;\n        /** @type {?} */\n        const outsideBelow = element.top > containerBounds.bottom;\n        /** @type {?} */\n        const outsideLeft = element.right < containerBounds.left;\n        /** @type {?} */\n        const outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    }));\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some((/**\n     * @param {?} scrollContainerRect\n     * @return {?}\n     */\n    scrollContainerRect => {\n        /** @type {?} */\n        const clippedAbove = element.top < scrollContainerRect.top;\n        /** @type {?} */\n        const clippedBelow = element.bottom > scrollContainerRect.bottom;\n        /** @type {?} */\n        const clippedLeft = element.left < scrollContainerRect.left;\n        /** @type {?} */\n        const clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    }));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nclass RepositionScrollStrategy {\n    /**\n     * @param {?} _scrollDispatcher\n     * @param {?} _viewportRuler\n     * @param {?} _ngZone\n     * @param {?=} _config\n     */\n    constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    attach(overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    }\n    /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    enable() {\n        if (!this._scrollSubscription) {\n            /** @type {?} */\n            const throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe((/**\n             * @return {?}\n             */\n            () => {\n                this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (this._config && this._config.autoClose) {\n                    /** @type {?} */\n                    const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();\n                    const { width, height } = this._viewportRuler.getViewportSize();\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    /** @type {?} */\n                    const parentRects = [{ width, height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        this.disable();\n                        this._ngZone.run((/**\n                         * @return {?}\n                         */\n                        () => this._overlayRef.detach()));\n                    }\n                }\n            }));\n        }\n    }\n    /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    disable() {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    detach() {\n        this.disable();\n        this._overlayRef = (/** @type {?} */ (null));\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nclass ScrollStrategyOptions {\n    /**\n     * @param {?} _scrollDispatcher\n     * @param {?} _viewportRuler\n     * @param {?} _ngZone\n     * @param {?} document\n     */\n    constructor(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = (/**\n         * @return {?}\n         */\n        () => new NoopScrollStrategy());\n        /**\n         * Close the overlay as soon as the user scrolls.\n         * @param config Configuration to be used inside the scroll strategy.\n         */\n        this.close = (/**\n         * @param {?=} config\n         * @return {?}\n         */\n        (config) => new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config));\n        /**\n         * Block scrolling.\n         */\n        this.block = (/**\n         * @return {?}\n         */\n        () => new BlockScrollStrategy(this._viewportRuler, this._document));\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = (/**\n         * @param {?=} config\n         * @return {?}\n         */\n        (config) => new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config));\n        this._document = document;\n    }\n}\nScrollStrategyOptions.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nScrollStrategyOptions.ctorParameters = () => [\n    { type: ScrollDispatcher },\n    { type: ViewportRuler },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n/** @nocollapse */ ScrollStrategyOptions.ngInjectableDef = ɵɵdefineInjectable({ factory: function ScrollStrategyOptions_Factory() { return new ScrollStrategyOptions(ɵɵinject(ScrollDispatcher), ɵɵinject(ViewportRuler), ɵɵinject(NgZone), ɵɵinject(DOCUMENT)); }, token: ScrollStrategyOptions, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Initial configuration used when creating an overlay.\n */\nclass OverlayConfig {\n    /**\n     * @param {?=} config\n     */\n    constructor(config) {\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * Whether the overlay should be disposed of when the user goes backwards/forwards in history.\n         * Note that this usually doesn't include clicking on links (unless the user is using\n         * the `HashLocationStrategy`).\n         */\n        this.disposeOnNavigation = false;\n        if (config) {\n            /** @type {?} */\n            const configKeys = (/** @type {?} */ (Object.keys(config)));\n            for (const key of configKeys) {\n                if (config[key] !== undefined) {\n                    // TypeScript, as of version 3.5, sees the left-hand-side of this expression\n                    // as \"I don't know *which* key this is, so the only valid value is the intersection\n                    // of all the posible values.\" In this case, that happens to be `undefined`. TypeScript\n                    // is not smart enough to see that the right-hand-side is actually an access of the same\n                    // exact type with the same exact key, meaning that the value type must be identical.\n                    // So we use `any` to work around this.\n                    this[key] = (/** @type {?} */ (config[key]));\n                }\n            }\n        }\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The points of the origin element and the overlay element to connect.\n */\nclass ConnectionPositionPair {\n    /**\n     * @param {?} origin\n     * @param {?} overlay\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @param {?=} panelClass\n     */\n    constructor(origin, overlay, offsetX, offsetY, panelClass) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.panelClass = panelClass;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n}\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n * \\@docs-private\n */\nclass ScrollingVisibility {\n}\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nclass ConnectedOverlayPositionChange {\n    /**\n     * @param {?} connectionPair\n     * @param {?} scrollableViewProperties\n     */\n    constructor(connectionPair, scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n}\n/** @nocollapse */\nConnectedOverlayPositionChange.ctorParameters = () => [\n    { type: ConnectionPositionPair },\n    { type: ScrollingVisibility, decorators: [{ type: Optional }] }\n];\n/**\n * Validates whether a vertical position property matches the expected values.\n * \\@docs-private\n * @param {?} property Name of the property being validated.\n * @param {?} value Value of the property being validated.\n * @return {?}\n */\nfunction validateVerticalPosition(property, value) {\n    if (value !== 'top' && value !== 'bottom' && value !== 'center') {\n        throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` +\n            `Expected \"top\", \"bottom\" or \"center\".`);\n    }\n}\n/**\n * Validates whether a horizontal position property matches the expected values.\n * \\@docs-private\n * @param {?} property Name of the property being validated.\n * @param {?} value Value of the property being validated.\n * @return {?}\n */\nfunction validateHorizontalPosition(property, value) {\n    if (value !== 'start' && value !== 'end' && value !== 'center') {\n        throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` +\n            `Expected \"start\", \"end\" or \"center\".`);\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nclass OverlayKeyboardDispatcher {\n    /**\n     * @param {?} document\n     */\n    constructor(document) {\n        /**\n         * Currently attached overlays in the order they were attached.\n         */\n        this._attachedOverlays = [];\n        /**\n         * Keyboard event listener that will be attached to the body.\n         */\n        this._keydownListener = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            /** @type {?} */\n            const overlays = this._attachedOverlays;\n            for (let i = overlays.length - 1; i > -1; i--) {\n                // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.\n                // We want to target the most recent overlay, rather than trying to match where the event came\n                // from, because some components might open an overlay, but keep focus on a trigger element\n                // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,\n                // because we don't want overlays that don't handle keyboard events to block the ones below\n                // them that do.\n                if (overlays[i]._keydownEventSubscriptions > 0) {\n                    overlays[i]._keydownEvents.next(event);\n                    break;\n                }\n            }\n        });\n        this._document = document;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._detach();\n    }\n    /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    add(overlayRef) {\n        // Ensure that we don't get the same overlay multiple times.\n        this.remove(overlayRef);\n        // Lazily start dispatcher once first overlay is added\n        if (!this._isAttached) {\n            this._document.body.addEventListener('keydown', this._keydownListener);\n            this._isAttached = true;\n        }\n        this._attachedOverlays.push(overlayRef);\n    }\n    /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    remove(overlayRef) {\n        /** @type {?} */\n        const index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n        // Remove the global listener once there are no more overlays.\n        if (this._attachedOverlays.length === 0) {\n            this._detach();\n        }\n    }\n    /**\n     * Detaches the global keyboard event listener.\n     * @private\n     * @return {?}\n     */\n    _detach() {\n        if (this._isAttached) {\n            this._document.body.removeEventListener('keydown', this._keydownListener);\n            this._isAttached = false;\n        }\n    }\n}\nOverlayKeyboardDispatcher.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nOverlayKeyboardDispatcher.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n/** @nocollapse */ OverlayKeyboardDispatcher.ngInjectableDef = ɵɵdefineInjectable({ factory: function OverlayKeyboardDispatcher_Factory() { return new OverlayKeyboardDispatcher(ɵɵinject(DOCUMENT)); }, token: OverlayKeyboardDispatcher, providedIn: \"root\" });\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\n * @param {?} dispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n    return dispatcher || new OverlayKeyboardDispatcher(_document);\n}\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\n * @type {?}\n */\nconst OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n    // If there is already an OverlayKeyboardDispatcher available, use that.\n    // Otherwise, provide a new one.\n    provide: OverlayKeyboardDispatcher,\n    deps: [\n        [new Optional(), new SkipSelf(), OverlayKeyboardDispatcher],\n        (/** @type {?} */ (\n        // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n        // of the type expected by Angular\n        DOCUMENT))\n    ],\n    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Container inside which all overlays will render.\n */\nclass OverlayContainer {\n    /**\n     * @param {?} document\n     */\n    constructor(document) {\n        this._document = document;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    }\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    getContainerElement() {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    }\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @protected\n     * @return {?}\n     */\n    _createContainer() {\n        /** @type {?} */\n        const containerClass = 'cdk-overlay-container';\n        /** @type {?} */\n        const previousContainers = this._document.getElementsByClassName(containerClass);\n        // Remove any old containers. This can happen when transitioning from the server to the client.\n        for (let i = 0; i < previousContainers.length; i++) {\n            (/** @type {?} */ (previousContainers[i].parentNode)).removeChild(previousContainers[i]);\n        }\n        /** @type {?} */\n        const container = this._document.createElement('div');\n        container.classList.add(containerClass);\n        this._document.body.appendChild(container);\n        this._containerElement = container;\n    }\n}\nOverlayContainer.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nOverlayContainer.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n/** @nocollapse */ OverlayContainer.ngInjectableDef = ɵɵdefineInjectable({ factory: function OverlayContainer_Factory() { return new OverlayContainer(ɵɵinject(DOCUMENT)); }, token: OverlayContainer, providedIn: \"root\" });\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\n * @param {?} parentContainer\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n    return parentContainer || new OverlayContainer(_document);\n}\n/**\n * \\@docs-private \\@deprecated \\@breaking-change 8.0.0\n * @type {?}\n */\nconst OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: OverlayContainer,\n    deps: [\n        [new Optional(), new SkipSelf(), OverlayContainer],\n        (/** @type {?} */ (DOCUMENT))\n    ],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nclass OverlayRef {\n    /**\n     * @param {?} _portalOutlet\n     * @param {?} _host\n     * @param {?} _pane\n     * @param {?} _config\n     * @param {?} _ngZone\n     * @param {?} _keyboardDispatcher\n     * @param {?} _document\n     * @param {?=} _location\n     */\n    constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location) {\n        this._portalOutlet = _portalOutlet;\n        this._host = _host;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._document = _document;\n        this._location = _location;\n        this._backdropElement = null;\n        this._backdropClick = new Subject();\n        this._attachments = new Subject();\n        this._detachments = new Subject();\n        this._locationChanges = Subscription.EMPTY;\n        this._backdropClickHandler = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => this._backdropClick.next(event));\n        this._keydownEventsObservable = new Observable((/**\n         * @param {?} observer\n         * @return {?}\n         */\n        (observer) => {\n            /** @type {?} */\n            const subscription = this._keydownEvents.subscribe(observer);\n            this._keydownEventSubscriptions++;\n            return (/**\n             * @return {?}\n             */\n            () => {\n                subscription.unsubscribe();\n                this._keydownEventSubscriptions--;\n            });\n        }));\n        /**\n         * Stream of keydown events dispatched to this overlay.\n         */\n        this._keydownEvents = new Subject();\n        /**\n         * Amount of subscriptions to the keydown events.\n         */\n        this._keydownEventSubscriptions = 0;\n        if (_config.scrollStrategy) {\n            this._scrollStrategy = _config.scrollStrategy;\n            this._scrollStrategy.attach(this);\n        }\n        this._positionStrategy = _config.positionStrategy;\n    }\n    /**\n     * The overlay's HTML element\n     * @return {?}\n     */\n    get overlayElement() {\n        return this._pane;\n    }\n    /**\n     * The overlay's backdrop HTML element.\n     * @return {?}\n     */\n    get backdropElement() {\n        return this._backdropElement;\n    }\n    /**\n     * Wrapper around the panel element. Can be used for advanced\n     * positioning where a wrapper with specific styling is\n     * required around the overlay pane.\n     * @return {?}\n     */\n    get hostElement() {\n        return this._host;\n    }\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    attach(portal) {\n        /** @type {?} */\n        let attachResult = this._portalOutlet.attach(portal);\n        if (this._positionStrategy) {\n            this._positionStrategy.attach(this);\n        }\n        // Update the pane element with the given configuration.\n        if (!this._host.parentElement && this._previousHostParent) {\n            this._previousHostParent.appendChild(this._host);\n        }\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._scrollStrategy) {\n            this._scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable\n            .asObservable()\n            .pipe(take(1))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => {\n            // The overlay could've been detached before the zone has stabilized.\n            if (this.hasAttached()) {\n                this.updatePosition();\n            }\n        }));\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            this._toggleClasses(this._pane, this._config.panelClass, true);\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        // @breaking-change 8.0.0 remove the null check for `_location`\n        // once the constructor parameter is made required.\n        if (this._config.disposeOnNavigation && this._location) {\n            this._locationChanges = this._location.subscribe((/**\n             * @return {?}\n             */\n            () => this.dispose()));\n        }\n        return attachResult;\n    }\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    detach() {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._positionStrategy && this._positionStrategy.detach) {\n            this._positionStrategy.detach();\n        }\n        if (this._scrollStrategy) {\n            this._scrollStrategy.disable();\n        }\n        /** @type {?} */\n        const detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking.\n        this._keyboardDispatcher.remove(this);\n        // Keeping the host element in DOM the can cause scroll jank, because it still gets\n        // rendered, even though it's transparent and unclickable which is why we remove it.\n        this._detachContentWhenStable();\n        // Stop listening for location changes.\n        this._locationChanges.unsubscribe();\n        return detachmentResult;\n    }\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    dispose() {\n        /** @type {?} */\n        const isAttached = this.hasAttached();\n        if (this._positionStrategy) {\n            this._positionStrategy.dispose();\n        }\n        this._disposeScrollStrategy();\n        this.detachBackdrop();\n        this._locationChanges.unsubscribe();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        if (this._host && this._host.parentNode) {\n            this._host.parentNode.removeChild(this._host);\n            this._host = (/** @type {?} */ (null));\n        }\n        this._previousHostParent = this._pane = (/** @type {?} */ (null));\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    }\n    /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    hasAttached() {\n        return this._portalOutlet.hasAttached();\n    }\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    backdropClick() {\n        return this._backdropClick.asObservable();\n    }\n    /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    attachments() {\n        return this._attachments.asObservable();\n    }\n    /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    detachments() {\n        return this._detachments.asObservable();\n    }\n    /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    keydownEvents() {\n        return this._keydownEventsObservable;\n    }\n    /**\n     * Gets the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    getConfig() {\n        return this._config;\n    }\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    updatePosition() {\n        if (this._positionStrategy) {\n            this._positionStrategy.apply();\n        }\n    }\n    /**\n     * Switches to a new position strategy and updates the overlay position.\n     * @param {?} strategy\n     * @return {?}\n     */\n    updatePositionStrategy(strategy) {\n        if (strategy === this._positionStrategy) {\n            return;\n        }\n        if (this._positionStrategy) {\n            this._positionStrategy.dispose();\n        }\n        this._positionStrategy = strategy;\n        if (this.hasAttached()) {\n            strategy.attach(this);\n            this.updatePosition();\n        }\n    }\n    /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    updateSize(sizeConfig) {\n        this._config = Object.assign({}, this._config, sizeConfig);\n        this._updateElementSize();\n    }\n    /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    setDirection(dir) {\n        this._config = Object.assign({}, this._config, { direction: dir });\n        this._updateElementDirection();\n    }\n    /**\n     * Add a CSS class or an array of classes to the overlay pane.\n     * @param {?} classes\n     * @return {?}\n     */\n    addPanelClass(classes) {\n        if (this._pane) {\n            this._toggleClasses(this._pane, classes, true);\n        }\n    }\n    /**\n     * Remove a CSS class or an array of classes from the overlay pane.\n     * @param {?} classes\n     * @return {?}\n     */\n    removePanelClass(classes) {\n        if (this._pane) {\n            this._toggleClasses(this._pane, classes, false);\n        }\n    }\n    /**\n     * Returns the layout direction of the overlay panel.\n     * @return {?}\n     */\n    getDirection() {\n        /** @type {?} */\n        const direction = this._config.direction;\n        if (!direction) {\n            return 'ltr';\n        }\n        return typeof direction === 'string' ? direction : direction.value;\n    }\n    /**\n     * Switches to a new scroll strategy.\n     * @param {?} strategy\n     * @return {?}\n     */\n    updateScrollStrategy(strategy) {\n        if (strategy === this._scrollStrategy) {\n            return;\n        }\n        this._disposeScrollStrategy();\n        this._scrollStrategy = strategy;\n        if (this.hasAttached()) {\n            strategy.attach(this);\n            strategy.enable();\n        }\n    }\n    /**\n     * Updates the text direction of the overlay panel.\n     * @private\n     * @return {?}\n     */\n    _updateElementDirection() {\n        this._host.setAttribute('dir', this.getDirection());\n    }\n    /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @private\n     * @return {?}\n     */\n    _updateElementSize() {\n        if (!this._pane) {\n            return;\n        }\n        /** @type {?} */\n        const style = this._pane.style;\n        style.width = coerceCssPixelValue(this._config.width);\n        style.height = coerceCssPixelValue(this._config.height);\n        style.minWidth = coerceCssPixelValue(this._config.minWidth);\n        style.minHeight = coerceCssPixelValue(this._config.minHeight);\n        style.maxWidth = coerceCssPixelValue(this._config.maxWidth);\n        style.maxHeight = coerceCssPixelValue(this._config.maxHeight);\n    }\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @private\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    _togglePointerEvents(enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    }\n    /**\n     * Attaches a backdrop for this overlay.\n     * @private\n     * @return {?}\n     */\n    _attachBackdrop() {\n        /** @type {?} */\n        const showingClass = 'cdk-overlay-backdrop-showing';\n        this._backdropElement = this._document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._toggleClasses(this._backdropElement, this._config.backdropClass, true);\n        }\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        (/** @type {?} */ (this._host.parentElement)).insertBefore(this._backdropElement, this._host);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', this._backdropClickHandler);\n        // Add class to fade-in the backdrop after one frame.\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                requestAnimationFrame((/**\n                 * @return {?}\n                 */\n                () => {\n                    if (this._backdropElement) {\n                        this._backdropElement.classList.add(showingClass);\n                    }\n                }));\n            }));\n        }\n        else {\n            this._backdropElement.classList.add(showingClass);\n        }\n    }\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @private\n     * @return {?}\n     */\n    _updateStackingOrder() {\n        if (this._host.nextSibling) {\n            (/** @type {?} */ (this._host.parentNode)).appendChild(this._host);\n        }\n    }\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    detachBackdrop() {\n        /** @type {?} */\n        let backdropToDetach = this._backdropElement;\n        if (!backdropToDetach) {\n            return;\n        }\n        /** @type {?} */\n        let timeoutId;\n        /** @type {?} */\n        let finishDetach = (/**\n         * @return {?}\n         */\n        () => {\n            // It may not be attached to anything in certain cases (e.g. unit tests).\n            if (backdropToDetach) {\n                backdropToDetach.removeEventListener('click', this._backdropClickHandler);\n                backdropToDetach.removeEventListener('transitionend', finishDetach);\n                if (backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n            }\n            // It is possible that a new portal has been attached to this overlay since we started\n            // removing the backdrop. If that is the case, only clear the backdrop reference if it\n            // is still the same instance that we started to remove.\n            if (this._backdropElement == backdropToDetach) {\n                this._backdropElement = null;\n            }\n            if (this._config.backdropClass) {\n                this._toggleClasses((/** @type {?} */ (backdropToDetach)), this._config.backdropClass, false);\n            }\n            clearTimeout(timeoutId);\n        });\n        backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n        this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            (/** @type {?} */ (backdropToDetach)).addEventListener('transitionend', finishDetach);\n        }));\n        // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n        // In this case we make it unclickable and we try to remove it after a delay.\n        backdropToDetach.style.pointerEvents = 'none';\n        // Run this outside the Angular zone because there's nothing that Angular cares about.\n        // If it were to run inside the Angular zone, every test that used Overlay would have to be\n        // either async or fakeAsync.\n        timeoutId = this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => setTimeout(finishDetach, 500)));\n    }\n    /**\n     * Toggles a single CSS class or an array of classes on an element.\n     * @private\n     * @param {?} element\n     * @param {?} cssClasses\n     * @param {?} isAdd\n     * @return {?}\n     */\n    _toggleClasses(element, cssClasses, isAdd) {\n        /** @type {?} */\n        const classList = element.classList;\n        coerceArray(cssClasses).forEach((/**\n         * @param {?} cssClass\n         * @return {?}\n         */\n        cssClass => {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            isAdd ? classList.add(cssClass) : classList.remove(cssClass);\n        }));\n    }\n    /**\n     * Detaches the overlay content next time the zone stabilizes.\n     * @private\n     * @return {?}\n     */\n    _detachContentWhenStable() {\n        // Normally we wouldn't have to explicitly run this outside the `NgZone`, however\n        // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will\n        // be patched to run inside the zone, which will throw us into an infinite loop.\n        this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            // We can't remove the host here immediately, because the overlay pane's content\n            // might still be animating. This stream helps us avoid interrupting the animation\n            // by waiting for the pane to become empty.\n            /** @type {?} */\n            const subscription = this._ngZone.onStable\n                .asObservable()\n                .pipe(takeUntil(merge(this._attachments, this._detachments)))\n                .subscribe((/**\n             * @return {?}\n             */\n            () => {\n                // Needs a couple of checks for the pane and host, because\n                // they may have been removed by the time the zone stabilizes.\n                if (!this._pane || !this._host || this._pane.children.length === 0) {\n                    if (this._pane && this._config.panelClass) {\n                        this._toggleClasses(this._pane, this._config.panelClass, false);\n                    }\n                    if (this._host && this._host.parentElement) {\n                        this._previousHostParent = this._host.parentElement;\n                        this._previousHostParent.removeChild(this._host);\n                    }\n                    subscription.unsubscribe();\n                }\n            }));\n        }));\n    }\n    /**\n     * Disposes of a scroll strategy.\n     * @private\n     * @return {?}\n     */\n    _disposeScrollStrategy() {\n        /** @type {?} */\n        const scrollStrategy = this._scrollStrategy;\n        if (scrollStrategy) {\n            scrollStrategy.disable();\n            if (scrollStrategy.detach) {\n                scrollStrategy.detach();\n            }\n        }\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// TODO: refactor clipping detection into a separate thing (part of scrolling module)\n// TODO: doesn't handle both flexible width and height when it has to scroll along both axis.\n/**\n * Class to be added to the overlay bounding box.\n * @type {?}\n */\nconst boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nclass FlexibleConnectedPositionStrategy {\n    /**\n     * @param {?} connectedTo\n     * @param {?} _viewportRuler\n     * @param {?} _document\n     * @param {?} _platform\n     * @param {?} _overlayContainer\n     */\n    constructor(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        this._platform = _platform;\n        this._overlayContainer = _overlayContainer;\n        /**\n         * Last size used for the bounding box. Used to avoid resizing the overlay after open.\n         */\n        this._lastBoundingBoxSize = { width: 0, height: 0 };\n        /**\n         * Whether the overlay was pushed in a previous positioning.\n         */\n        this._isPushed = false;\n        /**\n         * Whether the overlay can be pushed on-screen on the initial open.\n         */\n        this._canPush = true;\n        /**\n         * Whether the overlay can grow via flexible width/height after the initial open.\n         */\n        this._growAfterOpen = false;\n        /**\n         * Whether the overlay's width and height can be constrained to fit within the viewport.\n         */\n        this._hasFlexibleDimensions = true;\n        /**\n         * Whether the overlay position is locked.\n         */\n        this._positionLocked = false;\n        /**\n         * Amount of space that must be maintained between the overlay and the edge of the viewport.\n         */\n        this._viewportMargin = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this._scrollables = [];\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        /**\n         * Subject that emits whenever the position changes.\n         */\n        this._positionChanges = new Subject();\n        /**\n         * Subscription to viewport size changes.\n         */\n        this._resizeSubscription = Subscription.EMPTY;\n        /**\n         * Default offset for the overlay along the x axis.\n         */\n        this._offsetX = 0;\n        /**\n         * Default offset for the overlay along the y axis.\n         */\n        this._offsetY = 0;\n        /**\n         * Keeps track of the CSS classes that the position strategy has applied on the overlay panel.\n         */\n        this._appliedPanelClasses = [];\n        /**\n         * Observable sequence of position changes.\n         */\n        this.positionChanges = this._positionChanges.asObservable();\n        this.setOrigin(connectedTo);\n    }\n    /**\n     * Ordered list of preferred positions, from most to least desirable.\n     * @return {?}\n     */\n    get positions() {\n        return this._preferredPositions;\n    }\n    /**\n     * Attaches this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    attach(overlayRef) {\n        if (this._overlayRef && overlayRef !== this._overlayRef) {\n            throw Error('This position strategy is already attached to an overlay');\n        }\n        this._validatePositions();\n        overlayRef.hostElement.classList.add(boundingBoxClass);\n        this._overlayRef = overlayRef;\n        this._boundingBox = overlayRef.hostElement;\n        this._pane = overlayRef.overlayElement;\n        this._isDisposed = false;\n        this._isInitialRender = true;\n        this._lastPosition = null;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe((/**\n         * @return {?}\n         */\n        () => {\n            // When the window is resized, we want to trigger the next reposition as if it\n            // was an initial render, in order for the strategy to pick a new optimal position,\n            // otherwise position locking will cause it to stay at the old one.\n            this._isInitialRender = true;\n            this.apply();\n        }));\n    }\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin best fits on-screen.\n     *\n     * The selection of a position goes as follows:\n     *  - If any positions fit completely within the viewport as-is,\n     *      choose the first position that does so.\n     *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,\n     *      choose the position with the greatest available size modified by the positions' weight.\n     *  - If pushing is enabled, take the position that went off-screen the least and push it\n     *      on-screen.\n     *  - If none of the previous criteria were met, use the position that goes off-screen the least.\n     * \\@docs-private\n     * @return {?}\n     */\n    apply() {\n        // We shouldn't do anything if the strategy was disposed or we're on the server.\n        if (this._isDisposed || !this._platform.isBrowser) {\n            return;\n        }\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the old position, in order to\n        // prevent the overlay from jumping around.\n        if (!this._isInitialRender && this._positionLocked && this._lastPosition) {\n            this.reapplyLastPosition();\n            return;\n        }\n        this._clearPanelClasses();\n        this._resetOverlayElementStyles();\n        this._resetBoundingBoxStyles();\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        // We use the viewport rect to determine whether a position would go off-screen.\n        this._viewportRect = this._getNarrowedViewportRect();\n        this._originRect = this._getOriginRect();\n        this._overlayRect = this._pane.getBoundingClientRect();\n        /** @type {?} */\n        const originRect = this._originRect;\n        /** @type {?} */\n        const overlayRect = this._overlayRect;\n        /** @type {?} */\n        const viewportRect = this._viewportRect;\n        // Positions where the overlay will fit with flexible dimensions.\n        /** @type {?} */\n        const flexibleFits = [];\n        // Fallback if none of the preferred positions fit within the viewport.\n        /** @type {?} */\n        let fallback;\n        // Go through each of the preferred positions looking for a good fit.\n        // If a good fit is found, it will be applied immediately.\n        for (let pos of this._preferredPositions) {\n            // Get the exact (x, y) coordinate for the point-of-origin on the origin element.\n            /** @type {?} */\n            let originPoint = this._getOriginPoint(originRect, pos);\n            // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the\n            // overlay in this position. We use the top-left corner for calculations and later translate\n            // this into an appropriate (top, left, bottom, right) style.\n            /** @type {?} */\n            let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\n            // Calculate how well the overlay would fit into the viewport with this point.\n            /** @type {?} */\n            let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);\n            // If the overlay, without any further work, fits into the viewport, use this position.\n            if (overlayFit.isCompletelyWithinViewport) {\n                this._isPushed = false;\n                this._applyPosition(pos, originPoint);\n                return;\n            }\n            // If the overlay has flexible dimensions, we can use this position\n            // so long as there's enough space for the minimum dimensions.\n            if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {\n                // Save positions where the overlay will fit with flexible dimensions. We will use these\n                // if none of the positions fit *without* flexible dimensions.\n                flexibleFits.push({\n                    position: pos,\n                    origin: originPoint,\n                    overlayRect,\n                    boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)\n                });\n                continue;\n            }\n            // If the current preferred position does not fit on the screen, remember the position\n            // if it has more visible area on-screen than we've seen and move onto the next preferred\n            // position.\n            if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {\n                fallback = { overlayFit, overlayPoint, originPoint, position: pos, overlayRect };\n            }\n        }\n        // If there are any positions where the overlay would fit with flexible dimensions, choose the\n        // one that has the greatest area available modified by the position's weight\n        if (flexibleFits.length) {\n            /** @type {?} */\n            let bestFit = null;\n            /** @type {?} */\n            let bestScore = -1;\n            for (const fit of flexibleFits) {\n                /** @type {?} */\n                const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestFit = fit;\n                }\n            }\n            this._isPushed = false;\n            this._applyPosition((/** @type {?} */ (bestFit)).position, (/** @type {?} */ (bestFit)).origin);\n            return;\n        }\n        // When none of the preferred positions fit within the viewport, take the position\n        // that went off-screen the least and attempt to push it on-screen.\n        if (this._canPush) {\n            // TODO(jelbourn): after pushing, the opening \"direction\" of the overlay might not make sense.\n            this._isPushed = true;\n            this._applyPosition((/** @type {?} */ (fallback)).position, (/** @type {?} */ (fallback)).originPoint);\n            return;\n        }\n        // All options for getting the overlay within the viewport have been exhausted, so go with the\n        // position that went off-screen the least.\n        this._applyPosition((/** @type {?} */ (fallback)).position, (/** @type {?} */ (fallback)).originPoint);\n    }\n    /**\n     * @return {?}\n     */\n    detach() {\n        this._clearPanelClasses();\n        this._lastPosition = null;\n        this._previousPushAmount = null;\n        this._resizeSubscription.unsubscribe();\n    }\n    /**\n     * Cleanup after the element gets destroyed.\n     * @return {?}\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        // We can't use `_resetBoundingBoxStyles` here, because it resets\n        // some properties to zero, rather than removing them.\n        if (this._boundingBox) {\n            extendStyles(this._boundingBox.style, (/** @type {?} */ ({\n                top: '',\n                left: '',\n                right: '',\n                bottom: '',\n                height: '',\n                width: '',\n                alignItems: '',\n                justifyContent: '',\n            })));\n        }\n        if (this._pane) {\n            this._resetOverlayElementStyles();\n        }\n        if (this._overlayRef) {\n            this._overlayRef.hostElement.classList.remove(boundingBoxClass);\n        }\n        this.detach();\n        this._positionChanges.complete();\n        this._overlayRef = this._boundingBox = (/** @type {?} */ (null));\n        this._isDisposed = true;\n    }\n    /**\n     * This re-aligns the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    reapplyLastPosition() {\n        if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {\n            this._originRect = this._getOriginRect();\n            this._overlayRect = this._pane.getBoundingClientRect();\n            this._viewportRect = this._getNarrowedViewportRect();\n            /** @type {?} */\n            const lastPosition = this._lastPosition || this._preferredPositions[0];\n            /** @type {?} */\n            const originPoint = this._getOriginPoint(this._originRect, lastPosition);\n            this._applyPosition(lastPosition, originPoint);\n        }\n    }\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} scrollables\n     * @return {THIS}\n     */\n    withScrollableContainers(scrollables) {\n        (/** @type {?} */ (this))._scrollables = scrollables;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Adds new preferred positions.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} positions List of positions options for this overlay.\n     * @return {THIS}\n     */\n    withPositions(positions) {\n        (/** @type {?} */ (this))._preferredPositions = positions;\n        // If the last calculated position object isn't part of the positions anymore, clear\n        // it in order to avoid it being picked up if the consumer tries to re-apply.\n        if (positions.indexOf((/** @type {?} */ ((/** @type {?} */ (this))._lastPosition))) === -1) {\n            (/** @type {?} */ (this))._lastPosition = null;\n        }\n        (/** @type {?} */ (this))._validatePositions();\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} margin Required margin between the overlay and the viewport edge in pixels.\n     * @return {THIS}\n     */\n    withViewportMargin(margin) {\n        (/** @type {?} */ (this))._viewportMargin = margin;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets whether the overlay's width and height can be constrained to fit within the viewport.\n     * @template THIS\n     * @this {THIS}\n     * @param {?=} flexibleDimensions\n     * @return {THIS}\n     */\n    withFlexibleDimensions(flexibleDimensions = true) {\n        (/** @type {?} */ (this))._hasFlexibleDimensions = flexibleDimensions;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets whether the overlay can grow after the initial open via flexible width/height.\n     * @template THIS\n     * @this {THIS}\n     * @param {?=} growAfterOpen\n     * @return {THIS}\n     */\n    withGrowAfterOpen(growAfterOpen = true) {\n        (/** @type {?} */ (this))._growAfterOpen = growAfterOpen;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets whether the overlay can be pushed on-screen if none of the provided positions fit.\n     * @template THIS\n     * @this {THIS}\n     * @param {?=} canPush\n     * @return {THIS}\n     */\n    withPush(canPush = true) {\n        (/** @type {?} */ (this))._canPush = canPush;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @template THIS\n     * @this {THIS}\n     * @param {?=} isLocked Whether the overlay should locked in.\n     * @return {THIS}\n     */\n    withLockedPosition(isLocked = true) {\n        (/** @type {?} */ (this))._positionLocked = isLocked;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the origin, relative to which to position the overlay.\n     * Using an element origin is useful for building components that need to be positioned\n     * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be\n     * used for cases like contextual menus which open relative to the user's pointer.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} origin Reference to the new origin.\n     * @return {THIS}\n     */\n    setOrigin(origin) {\n        (/** @type {?} */ (this))._origin = origin;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the default offset for the overlay's connection point on the x-axis.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} offset New offset in the X axis.\n     * @return {THIS}\n     */\n    withDefaultOffsetX(offset) {\n        (/** @type {?} */ (this))._offsetX = offset;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the default offset for the overlay's connection point on the y-axis.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} offset New offset in the Y axis.\n     * @return {THIS}\n     */\n    withDefaultOffsetY(offset) {\n        (/** @type {?} */ (this))._offsetY = offset;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Configures that the position strategy should set a `transform-origin` on some elements\n     * inside the overlay, depending on the current position that is being applied. This is\n     * useful for the cases where the origin of an animation can change depending on the\n     * alignment of the overlay.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} selector CSS selector that will be used to find the target\n     *    elements onto which to set the transform origin.\n     * @return {THIS}\n     */\n    withTransformOriginOn(selector) {\n        (/** @type {?} */ (this))._transformOriginSelector = selector;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @private\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    _getOriginPoint(originRect, pos) {\n        /** @type {?} */\n        let x;\n        if (pos.originX == 'center') {\n            // Note: when centering we should always use the `left`\n            // offset, otherwise the position will be wrong in RTL.\n            x = originRect.left + (originRect.width / 2);\n        }\n        else {\n            /** @type {?} */\n            const startX = this._isRtl() ? originRect.right : originRect.left;\n            /** @type {?} */\n            const endX = this._isRtl() ? originRect.left : originRect.right;\n            x = pos.originX == 'start' ? startX : endX;\n        }\n        /** @type {?} */\n        let y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x, y };\n    }\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected.\n     * @private\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} pos\n     * @return {?}\n     */\n    _getOverlayPoint(originPoint, overlayRect, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the\n        // potential overlay position relative to the origin point.\n        /** @type {?} */\n        let overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl() ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl() ? 0 : -overlayRect.width;\n        }\n        /** @type {?} */\n        let overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) coordinates of the overlay.\n        return {\n            x: originPoint.x + overlayStartX,\n            y: originPoint.y + overlayStartY,\n        };\n    }\n    /**\n     * Gets how well an overlay at the given point will fit within the viewport.\n     * @private\n     * @param {?} point\n     * @param {?} overlay\n     * @param {?} viewport\n     * @param {?} position\n     * @return {?}\n     */\n    _getOverlayFit(point, overlay, viewport, position) {\n        let { x, y } = point;\n        /** @type {?} */\n        let offsetX = this._getOffset(position, 'x');\n        /** @type {?} */\n        let offsetY = this._getOffset(position, 'y');\n        // Account for the offsets since they could push the overlay out of the viewport.\n        if (offsetX) {\n            x += offsetX;\n        }\n        if (offsetY) {\n            y += offsetY;\n        }\n        // How much the overlay would overflow at this position, on each side.\n        /** @type {?} */\n        let leftOverflow = 0 - x;\n        /** @type {?} */\n        let rightOverflow = (x + overlay.width) - viewport.width;\n        /** @type {?} */\n        let topOverflow = 0 - y;\n        /** @type {?} */\n        let bottomOverflow = (y + overlay.height) - viewport.height;\n        // Visible parts of the element on each axis.\n        /** @type {?} */\n        let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);\n        /** @type {?} */\n        let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);\n        /** @type {?} */\n        let visibleArea = visibleWidth * visibleHeight;\n        return {\n            visibleArea,\n            isCompletelyWithinViewport: (overlay.width * overlay.height) === visibleArea,\n            fitsInViewportVertically: visibleHeight === overlay.height,\n            fitsInViewportHorizontally: visibleWidth == overlay.width,\n        };\n    }\n    /**\n     * Whether the overlay can fit within the viewport when it may resize either its width or height.\n     * @private\n     * @param {?} fit How well the overlay fits in the viewport at some position.\n     * @param {?} point The (x, y) coordinates of the overlat at some position.\n     * @param {?} viewport The geometry of the viewport.\n     * @return {?}\n     */\n    _canFitWithFlexibleDimensions(fit, point, viewport) {\n        if (this._hasFlexibleDimensions) {\n            /** @type {?} */\n            const availableHeight = viewport.bottom - point.y;\n            /** @type {?} */\n            const availableWidth = viewport.right - point.x;\n            /** @type {?} */\n            const minHeight = this._overlayRef.getConfig().minHeight;\n            /** @type {?} */\n            const minWidth = this._overlayRef.getConfig().minWidth;\n            /** @type {?} */\n            const verticalFit = fit.fitsInViewportVertically ||\n                (minHeight != null && minHeight <= availableHeight);\n            /** @type {?} */\n            const horizontalFit = fit.fitsInViewportHorizontally ||\n                (minWidth != null && minWidth <= availableWidth);\n            return verticalFit && horizontalFit;\n        }\n        return false;\n    }\n    /**\n     * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\n     * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the\n     * right and bottom).\n     *\n     * @private\n     * @param {?} start Starting point from which the overlay is pushed.\n     * @param {?} overlay Dimensions of the overlay.\n     * @param {?} scrollPosition Current viewport scroll position.\n     * @return {?} The point at which to position the overlay after pushing. This is effectively a new\n     *     originPoint.\n     */\n    _pushOverlayOnScreen(start, overlay, scrollPosition) {\n        // If the position is locked and we've pushed the overlay already, reuse the previous push\n        // amount, rather than pushing it again. If we were to continue pushing, the element would\n        // remain in the viewport, which goes against the expectations when position locking is enabled.\n        if (this._previousPushAmount && this._positionLocked) {\n            return {\n                x: start.x + this._previousPushAmount.x,\n                y: start.y + this._previousPushAmount.y\n            };\n        }\n        /** @type {?} */\n        const viewport = this._viewportRect;\n        // Determine how much the overlay goes outside the viewport on each\n        // side, which we'll use to decide which direction to push it.\n        /** @type {?} */\n        const overflowRight = Math.max(start.x + overlay.width - viewport.right, 0);\n        /** @type {?} */\n        const overflowBottom = Math.max(start.y + overlay.height - viewport.bottom, 0);\n        /** @type {?} */\n        const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);\n        /** @type {?} */\n        const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);\n        // Amount by which to push the overlay in each axis such that it remains on-screen.\n        /** @type {?} */\n        let pushX = 0;\n        /** @type {?} */\n        let pushY = 0;\n        // If the overlay fits completely within the bounds of the viewport, push it from whichever\n        // direction is goes off-screen. Otherwise, push the top-left corner such that its in the\n        // viewport and allow for the trailing end of the overlay to go out of bounds.\n        if (overlay.width <= viewport.width) {\n            pushX = overflowLeft || -overflowRight;\n        }\n        else {\n            pushX = start.x < this._viewportMargin ? (viewport.left - scrollPosition.left) - start.x : 0;\n        }\n        if (overlay.height <= viewport.height) {\n            pushY = overflowTop || -overflowBottom;\n        }\n        else {\n            pushY = start.y < this._viewportMargin ? (viewport.top - scrollPosition.top) - start.y : 0;\n        }\n        this._previousPushAmount = { x: pushX, y: pushY };\n        return {\n            x: start.x + pushX,\n            y: start.y + pushY,\n        };\n    }\n    /**\n     * Applies a computed position to the overlay and emits a position change.\n     * @private\n     * @param {?} position The position preference\n     * @param {?} originPoint The point on the origin element where the overlay is connected.\n     * @return {?}\n     */\n    _applyPosition(position, originPoint) {\n        this._setTransformOrigin(position);\n        this._setOverlayElementStyles(originPoint, position);\n        this._setBoundingBoxStyles(originPoint, position);\n        if (position.panelClass) {\n            this._addPanelClasses(position.panelClass);\n        }\n        // Save the last connected position in case the position needs to be re-calculated.\n        this._lastPosition = position;\n        // Notify that the position has been changed along with its change properties.\n        // We only emit if we've got any subscriptions, because the scroll visibility\n        // calculcations can be somewhat expensive.\n        if (this._positionChanges.observers.length) {\n            /** @type {?} */\n            const scrollableViewProperties = this._getScrollVisibility();\n            /** @type {?} */\n            const changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);\n            this._positionChanges.next(changeEvent);\n        }\n        this._isInitialRender = false;\n    }\n    /**\n     * Sets the transform origin based on the configured selector and the passed-in position.\n     * @private\n     * @param {?} position\n     * @return {?}\n     */\n    _setTransformOrigin(position) {\n        if (!this._transformOriginSelector) {\n            return;\n        }\n        /** @type {?} */\n        const elements = (/** @type {?} */ (this._boundingBox)).querySelectorAll(this._transformOriginSelector);\n        /** @type {?} */\n        let xOrigin;\n        /** @type {?} */\n        let yOrigin = position.overlayY;\n        if (position.overlayX === 'center') {\n            xOrigin = 'center';\n        }\n        else if (this._isRtl()) {\n            xOrigin = position.overlayX === 'start' ? 'right' : 'left';\n        }\n        else {\n            xOrigin = position.overlayX === 'start' ? 'left' : 'right';\n        }\n        for (let i = 0; i < elements.length; i++) {\n            elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;\n        }\n    }\n    /**\n     * Gets the position and size of the overlay's sizing container.\n     *\n     * This method does no measuring and applies no styles so that we can cheaply compute the\n     * bounds for all positions and choose the best fit based on these results.\n     * @private\n     * @param {?} origin\n     * @param {?} position\n     * @return {?}\n     */\n    _calculateBoundingBoxRect(origin, position) {\n        /** @type {?} */\n        const viewport = this._viewportRect;\n        /** @type {?} */\n        const isRtl = this._isRtl();\n        /** @type {?} */\n        let height;\n        /** @type {?} */\n        let top;\n        /** @type {?} */\n        let bottom;\n        if (position.overlayY === 'top') {\n            // Overlay is opening \"downward\" and thus is bound by the bottom viewport edge.\n            top = origin.y;\n            height = viewport.height - top + this._viewportMargin;\n        }\n        else if (position.overlayY === 'bottom') {\n            // Overlay is opening \"upward\" and thus is bound by the top viewport edge. We need to add\n            // the viewport margin back in, because the viewport rect is narrowed down to remove the\n            // margin, whereas the `origin` position is calculated based on its `ClientRect`.\n            bottom = viewport.height - origin.y + this._viewportMargin * 2;\n            height = viewport.height - bottom + this._viewportMargin;\n        }\n        else {\n            // If neither top nor bottom, it means that the overlay is vertically centered on the\n            // origin point. Note that we want the position relative to the viewport, rather than\n            // the page, which is why we don't use something like `viewport.bottom - origin.y` and\n            // `origin.y - viewport.top`.\n            /** @type {?} */\n            const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);\n            /** @type {?} */\n            const previousHeight = this._lastBoundingBoxSize.height;\n            height = smallestDistanceToViewportEdge * 2;\n            top = origin.y - smallestDistanceToViewportEdge;\n            if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {\n                top = origin.y - (previousHeight / 2);\n            }\n        }\n        // The overlay is opening 'right-ward' (the content flows to the right).\n        /** @type {?} */\n        const isBoundedByRightViewportEdge = (position.overlayX === 'start' && !isRtl) ||\n            (position.overlayX === 'end' && isRtl);\n        // The overlay is opening 'left-ward' (the content flows to the left).\n        /** @type {?} */\n        const isBoundedByLeftViewportEdge = (position.overlayX === 'end' && !isRtl) ||\n            (position.overlayX === 'start' && isRtl);\n        /** @type {?} */\n        let width;\n        /** @type {?} */\n        let left;\n        /** @type {?} */\n        let right;\n        if (isBoundedByLeftViewportEdge) {\n            right = viewport.width - origin.x + this._viewportMargin;\n            width = origin.x - this._viewportMargin;\n        }\n        else if (isBoundedByRightViewportEdge) {\n            left = origin.x;\n            width = viewport.right - origin.x;\n        }\n        else {\n            // If neither start nor end, it means that the overlay is horizontally centered on the\n            // origin point. Note that we want the position relative to the viewport, rather than\n            // the page, which is why we don't use something like `viewport.right - origin.x` and\n            // `origin.x - viewport.left`.\n            /** @type {?} */\n            const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);\n            /** @type {?} */\n            const previousWidth = this._lastBoundingBoxSize.width;\n            width = smallestDistanceToViewportEdge * 2;\n            left = origin.x - smallestDistanceToViewportEdge;\n            if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {\n                left = origin.x - (previousWidth / 2);\n            }\n        }\n        return { top: (/** @type {?} */ (top)), left: (/** @type {?} */ (left)), bottom: (/** @type {?} */ (bottom)), right: (/** @type {?} */ (right)), width, height };\n    }\n    /**\n     * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\n     * origin's connection point and stetches to the bounds of the viewport.\n     *\n     * @private\n     * @param {?} origin The point on the origin element where the overlay is connected.\n     * @param {?} position The position preference\n     * @return {?}\n     */\n    _setBoundingBoxStyles(origin, position) {\n        /** @type {?} */\n        const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);\n        // It's weird if the overlay *grows* while scrolling, so we take the last size into account\n        // when applying a new size.\n        if (!this._isInitialRender && !this._growAfterOpen) {\n            boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);\n            boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);\n        }\n        /** @type {?} */\n        const styles = (/** @type {?} */ ({}));\n        if (this._hasExactPosition()) {\n            styles.top = styles.left = '0';\n            styles.bottom = styles.right = '';\n            styles.width = styles.height = '100%';\n        }\n        else {\n            /** @type {?} */\n            const maxHeight = this._overlayRef.getConfig().maxHeight;\n            /** @type {?} */\n            const maxWidth = this._overlayRef.getConfig().maxWidth;\n            styles.height = coerceCssPixelValue(boundingBoxRect.height);\n            styles.top = coerceCssPixelValue(boundingBoxRect.top);\n            styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);\n            styles.width = coerceCssPixelValue(boundingBoxRect.width);\n            styles.left = coerceCssPixelValue(boundingBoxRect.left);\n            styles.right = coerceCssPixelValue(boundingBoxRect.right);\n            // Push the pane content towards the proper direction.\n            if (position.overlayX === 'center') {\n                styles.alignItems = 'center';\n            }\n            else {\n                styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';\n            }\n            if (position.overlayY === 'center') {\n                styles.justifyContent = 'center';\n            }\n            else {\n                styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';\n            }\n            if (maxHeight) {\n                styles.maxHeight = coerceCssPixelValue(maxHeight);\n            }\n            if (maxWidth) {\n                styles.maxWidth = coerceCssPixelValue(maxWidth);\n            }\n        }\n        this._lastBoundingBoxSize = boundingBoxRect;\n        extendStyles((/** @type {?} */ (this._boundingBox)).style, styles);\n    }\n    /**\n     * Resets the styles for the bounding box so that a new positioning can be computed.\n     * @private\n     * @return {?}\n     */\n    _resetBoundingBoxStyles() {\n        extendStyles((/** @type {?} */ (this._boundingBox)).style, (/** @type {?} */ ({\n            top: '0',\n            left: '0',\n            right: '0',\n            bottom: '0',\n            height: '',\n            width: '',\n            alignItems: '',\n            justifyContent: '',\n        })));\n    }\n    /**\n     * Resets the styles for the overlay pane so that a new positioning can be computed.\n     * @private\n     * @return {?}\n     */\n    _resetOverlayElementStyles() {\n        extendStyles(this._pane.style, (/** @type {?} */ ({\n            top: '',\n            left: '',\n            bottom: '',\n            right: '',\n            position: '',\n            transform: '',\n        })));\n    }\n    /**\n     * Sets positioning styles to the overlay element.\n     * @private\n     * @param {?} originPoint\n     * @param {?} position\n     * @return {?}\n     */\n    _setOverlayElementStyles(originPoint, position) {\n        /** @type {?} */\n        const styles = (/** @type {?} */ ({}));\n        if (this._hasExactPosition()) {\n            /** @type {?} */\n            const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n            extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));\n            extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));\n        }\n        else {\n            styles.position = 'static';\n        }\n        // Use a transform to apply the offsets. We do this because the `center` positions rely on\n        // being in the normal flex flow and setting a `top` / `left` at all will completely throw\n        // off the position. We also can't use margins, because they won't have an effect in some\n        // cases where the element doesn't have anything to \"push off of\". Finally, this works\n        // better both with flexible and non-flexible positioning.\n        /** @type {?} */\n        let transformString = '';\n        /** @type {?} */\n        let offsetX = this._getOffset(position, 'x');\n        /** @type {?} */\n        let offsetY = this._getOffset(position, 'y');\n        if (offsetX) {\n            transformString += `translateX(${offsetX}px) `;\n        }\n        if (offsetY) {\n            transformString += `translateY(${offsetY}px)`;\n        }\n        styles.transform = transformString.trim();\n        // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because\n        // we need these values to both be set to \"100%\" for the automatic flexible sizing to work.\n        // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.\n        if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxHeight) {\n            styles.maxHeight = '';\n        }\n        if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxWidth) {\n            styles.maxWidth = '';\n        }\n        extendStyles(this._pane.style, styles);\n    }\n    /**\n     * Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing.\n     * @private\n     * @param {?} position\n     * @param {?} originPoint\n     * @param {?} scrollPosition\n     * @return {?}\n     */\n    _getExactOverlayY(position, originPoint, scrollPosition) {\n        // Reset any existing styles. This is necessary in case the\n        // preferred position has changed since the last `apply`.\n        /** @type {?} */\n        let styles = (/** @type {?} */ ({ top: null, bottom: null }));\n        /** @type {?} */\n        let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n        if (this._isPushed) {\n            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n        }\n        /** @type {?} */\n        let virtualKeyboardOffset = this._overlayContainer.getContainerElement().getBoundingClientRect().top;\n        // Normally this would be zero, however when the overlay is attached to an input (e.g. in an\n        // autocomplete), mobile browsers will shift everything in order to put the input in the middle\n        // of the screen and to make space for the virtual keyboard. We need to account for this offset,\n        // otherwise our positioning will be thrown off.\n        overlayPoint.y -= virtualKeyboardOffset;\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear\n        // above or below the origin and the direction in which the element will expand.\n        if (position.overlayY === 'bottom') {\n            // When using `bottom`, we adjust the y position such that it is the distance\n            // from the bottom of the viewport rather than the top.\n            /** @type {?} */\n            const documentHeight = (/** @type {?} */ (this._document.documentElement)).clientHeight;\n            styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;\n        }\n        else {\n            styles.top = coerceCssPixelValue(overlayPoint.y);\n        }\n        return styles;\n    }\n    /**\n     * Gets the exact left/right for the overlay when not using flexible sizing or when pushing.\n     * @private\n     * @param {?} position\n     * @param {?} originPoint\n     * @param {?} scrollPosition\n     * @return {?}\n     */\n    _getExactOverlayX(position, originPoint, scrollPosition) {\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        /** @type {?} */\n        let styles = (/** @type {?} */ ({ left: null, right: null }));\n        /** @type {?} */\n        let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n        if (this._isPushed) {\n            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n        }\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        /** @type {?} */\n        let horizontalStyleProperty;\n        if (this._isRtl()) {\n            horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        if (horizontalStyleProperty === 'right') {\n            /** @type {?} */\n            const documentWidth = (/** @type {?} */ (this._document.documentElement)).clientWidth;\n            styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;\n        }\n        else {\n            styles.left = coerceCssPixelValue(overlayPoint.x);\n        }\n        return styles;\n    }\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @private\n     * @return {?}\n     */\n    _getScrollVisibility() {\n        // Note: needs fresh rects since the position could've changed.\n        /** @type {?} */\n        const originBounds = this._getOriginRect();\n        /** @type {?} */\n        const overlayBounds = this._pane.getBoundingClientRect();\n        // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers\n        // every time, we should be able to use the scrollTop of the containers if the size of those\n        // containers hasn't changed.\n        /** @type {?} */\n        const scrollContainerBounds = this._scrollables.map((/**\n         * @param {?} scrollable\n         * @return {?}\n         */\n        scrollable => {\n            return scrollable.getElementRef().nativeElement.getBoundingClientRect();\n        }));\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    }\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from its length.\n     * @private\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    _subtractOverflows(length, ...overflows) {\n        return overflows.reduce((/**\n         * @param {?} currentValue\n         * @param {?} currentOverflow\n         * @return {?}\n         */\n        (currentValue, currentOverflow) => {\n            return currentValue - Math.max(currentOverflow, 0);\n        }), length);\n    }\n    /**\n     * Narrows the given viewport rect by the current _viewportMargin.\n     * @private\n     * @return {?}\n     */\n    _getNarrowedViewportRect() {\n        // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,\n        // because we want to use the `clientWidth` and `clientHeight` as the base. The difference\n        // being that the client properties don't include the scrollbar, as opposed to `innerWidth`\n        // and `innerHeight` that do. This is necessary, because the overlay container uses\n        // 100% `width` and `height` which don't include the scrollbar either.\n        /** @type {?} */\n        const width = (/** @type {?} */ (this._document.documentElement)).clientWidth;\n        /** @type {?} */\n        const height = (/** @type {?} */ (this._document.documentElement)).clientHeight;\n        /** @type {?} */\n        const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n        return {\n            top: scrollPosition.top + this._viewportMargin,\n            left: scrollPosition.left + this._viewportMargin,\n            right: scrollPosition.left + width - this._viewportMargin,\n            bottom: scrollPosition.top + height - this._viewportMargin,\n            width: width - (2 * this._viewportMargin),\n            height: height - (2 * this._viewportMargin),\n        };\n    }\n    /**\n     * Whether the we're dealing with an RTL context\n     * @private\n     * @return {?}\n     */\n    _isRtl() {\n        return this._overlayRef.getDirection() === 'rtl';\n    }\n    /**\n     * Determines whether the overlay uses exact or flexible positioning.\n     * @private\n     * @return {?}\n     */\n    _hasExactPosition() {\n        return !this._hasFlexibleDimensions || this._isPushed;\n    }\n    /**\n     * Retrieves the offset of a position along the x or y axis.\n     * @private\n     * @param {?} position\n     * @param {?} axis\n     * @return {?}\n     */\n    _getOffset(position, axis) {\n        if (axis === 'x') {\n            // We don't do something like `position['offset' + axis]` in\n            // order to avoid breking minifiers that rename properties.\n            return position.offsetX == null ? this._offsetX : position.offsetX;\n        }\n        return position.offsetY == null ? this._offsetY : position.offsetY;\n    }\n    /**\n     * Validates that the current position match the expected values.\n     * @private\n     * @return {?}\n     */\n    _validatePositions() {\n        if (!this._preferredPositions.length) {\n            throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');\n        }\n        // TODO(crisbeto): remove these once Angular's template type\n        // checking is advanced enough to catch these cases.\n        this._preferredPositions.forEach((/**\n         * @param {?} pair\n         * @return {?}\n         */\n        pair => {\n            validateHorizontalPosition('originX', pair.originX);\n            validateVerticalPosition('originY', pair.originY);\n            validateHorizontalPosition('overlayX', pair.overlayX);\n            validateVerticalPosition('overlayY', pair.overlayY);\n        }));\n    }\n    /**\n     * Adds a single CSS class or an array of classes on the overlay panel.\n     * @private\n     * @param {?} cssClasses\n     * @return {?}\n     */\n    _addPanelClasses(cssClasses) {\n        if (this._pane) {\n            coerceArray(cssClasses).forEach((/**\n             * @param {?} cssClass\n             * @return {?}\n             */\n            cssClass => {\n                if (cssClass !== '' && this._appliedPanelClasses.indexOf(cssClass) === -1) {\n                    this._appliedPanelClasses.push(cssClass);\n                    this._pane.classList.add(cssClass);\n                }\n            }));\n        }\n    }\n    /**\n     * Clears the classes that the position strategy has applied from the overlay panel.\n     * @private\n     * @return {?}\n     */\n    _clearPanelClasses() {\n        if (this._pane) {\n            this._appliedPanelClasses.forEach((/**\n             * @param {?} cssClass\n             * @return {?}\n             */\n            cssClass => {\n                this._pane.classList.remove(cssClass);\n            }));\n            this._appliedPanelClasses = [];\n        }\n    }\n    /**\n     * Returns the ClientRect of the current origin.\n     * @private\n     * @return {?}\n     */\n    _getOriginRect() {\n        /** @type {?} */\n        const origin = this._origin;\n        if (origin instanceof ElementRef) {\n            return origin.nativeElement.getBoundingClientRect();\n        }\n        if (origin instanceof HTMLElement) {\n            return origin.getBoundingClientRect();\n        }\n        /** @type {?} */\n        const width = origin.width || 0;\n        /** @type {?} */\n        const height = origin.height || 0;\n        // If the origin is a point, return a client rect as if it was a 0x0 element at the point.\n        return {\n            top: origin.y,\n            bottom: origin.y + height,\n            left: origin.x,\n            right: origin.x + width,\n            height,\n            width\n        };\n    }\n}\n/**\n * Shallow-extends a stylesheet object with another stylesheet object.\n * @param {?} dest\n * @param {?} source\n * @return {?}\n */\nfunction extendStyles(dest, source) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            dest[key] = source[key];\n        }\n    }\n    return dest;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative to some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n * @deprecated Use `FlexibleConnectedPositionStrategy` instead.\n * \\@breaking-change 8.0.0\n */\nclass ConnectedPositionStrategy {\n    /**\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?} connectedTo\n     * @param {?} viewportRuler\n     * @param {?} document\n     * @param {?} platform\n     * @param {?} overlayContainer\n     */\n    constructor(originPos, overlayPos, connectedTo, viewportRuler, document, platform, overlayContainer) {\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        // Since the `ConnectedPositionStrategy` is deprecated and we don't want to maintain\n        // the extra logic, we create an instance of the positioning strategy that has some\n        // defaults that make it behave as the old position strategy and to which we'll\n        // proxy all of the API calls.\n        this._positionStrategy = new FlexibleConnectedPositionStrategy(connectedTo, viewportRuler, document, platform, overlayContainer)\n            .withFlexibleDimensions(false)\n            .withPush(false)\n            .withViewportMargin(0);\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    /**\n     * Whether the we're dealing with an RTL context\n     * @return {?}\n     */\n    get _isRtl() {\n        return this._overlayRef.getDirection() === 'rtl';\n    }\n    /**\n     * Emits an event when the connection point changes.\n     * @return {?}\n     */\n    get onPositionChange() {\n        return this._positionStrategy.positionChanges;\n    }\n    /**\n     * Ordered list of preferred positions, from most to least desirable.\n     * @return {?}\n     */\n    get positions() {\n        return this._preferredPositions;\n    }\n    /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    attach(overlayRef) {\n        this._overlayRef = overlayRef;\n        this._positionStrategy.attach(overlayRef);\n        if (this._direction) {\n            overlayRef.setDirection(this._direction);\n            this._direction = null;\n        }\n    }\n    /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    dispose() {\n        this._positionStrategy.dispose();\n    }\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    detach() {\n        this._positionStrategy.detach();\n    }\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    apply() {\n        this._positionStrategy.apply();\n    }\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    recalculateLastPosition() {\n        this._positionStrategy.reapplyLastPosition();\n    }\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    withScrollableContainers(scrollables) {\n        this._positionStrategy.withScrollableContainers(scrollables);\n    }\n    /**\n     * Adds a new preferred fallback position.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {THIS}\n     */\n    withFallbackPosition(originPos, overlayPos, offsetX, offsetY) {\n        /** @type {?} */\n        const position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        (/** @type {?} */ (this))._preferredPositions.push(position);\n        (/** @type {?} */ (this))._positionStrategy.withPositions((/** @type {?} */ (this))._preferredPositions);\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} dir New layout direction.\n     * @return {THIS}\n     */\n    withDirection(dir) {\n        // Since the direction might be declared before the strategy is attached,\n        // we save the value in a temporary property and we'll transfer it to the\n        // overlay ref on attachment.\n        if ((/** @type {?} */ (this))._overlayRef) {\n            (/** @type {?} */ (this))._overlayRef.setDirection(dir);\n        }\n        else {\n            (/** @type {?} */ (this))._direction = dir;\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @template THIS\n     * @this {THIS}\n     * @param {?} offset New offset in the X axis.\n     * @return {THIS}\n     */\n    withOffsetX(offset) {\n        (/** @type {?} */ (this))._positionStrategy.withDefaultOffsetX(offset);\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @template THIS\n     * @this {THIS}\n     * @param {?} offset New offset in the Y axis.\n     * @return {THIS}\n     */\n    withOffsetY(offset) {\n        (/** @type {?} */ (this))._positionStrategy.withDefaultOffsetY(offset);\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @template THIS\n     * @this {THIS}\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {THIS}\n     */\n    withLockedPosition(isLocked) {\n        (/** @type {?} */ (this))._positionStrategy.withLockedPosition(isLocked);\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {THIS}\n     */\n    withPositions(positions) {\n        (/** @type {?} */ (this))._preferredPositions = positions.slice();\n        (/** @type {?} */ (this))._positionStrategy.withPositions((/** @type {?} */ (this))._preferredPositions);\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} origin Reference to the new origin element.\n     * @return {THIS}\n     */\n    setOrigin(origin) {\n        (/** @type {?} */ (this))._positionStrategy.setOrigin(origin);\n        return (/** @type {?} */ (this));\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Class to be added to the overlay pane wrapper.\n * @type {?}\n */\nconst wrapperClass = 'cdk-global-overlay-wrapper';\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nclass GlobalPositionStrategy {\n    constructor() {\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    attach(overlayRef) {\n        /** @type {?} */\n        const config = overlayRef.getConfig();\n        this._overlayRef = overlayRef;\n        if (this._width && !config.width) {\n            overlayRef.updateSize({ width: this._width });\n        }\n        if (this._height && !config.height) {\n            overlayRef.updateSize({ height: this._height });\n        }\n        overlayRef.hostElement.classList.add(wrapperClass);\n        this._isDisposed = false;\n    }\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @template THIS\n     * @this {THIS}\n     * @param {?=} value New top offset.\n     * @return {THIS}\n     */\n    top(value = '') {\n        (/** @type {?} */ (this))._bottomOffset = '';\n        (/** @type {?} */ (this))._topOffset = value;\n        (/** @type {?} */ (this))._alignItems = 'flex-start';\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @template THIS\n     * @this {THIS}\n     * @param {?=} value New left offset.\n     * @return {THIS}\n     */\n    left(value = '') {\n        (/** @type {?} */ (this))._rightOffset = '';\n        (/** @type {?} */ (this))._leftOffset = value;\n        (/** @type {?} */ (this))._justifyContent = 'flex-start';\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @template THIS\n     * @this {THIS}\n     * @param {?=} value New bottom offset.\n     * @return {THIS}\n     */\n    bottom(value = '') {\n        (/** @type {?} */ (this))._topOffset = '';\n        (/** @type {?} */ (this))._bottomOffset = value;\n        (/** @type {?} */ (this))._alignItems = 'flex-end';\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @template THIS\n     * @this {THIS}\n     * @param {?=} value New right offset.\n     * @return {THIS}\n     */\n    right(value = '') {\n        (/** @type {?} */ (this))._leftOffset = '';\n        (/** @type {?} */ (this))._rightOffset = value;\n        (/** @type {?} */ (this))._justifyContent = 'flex-end';\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * \\@breaking-change 8.0.0\n     * @template THIS\n     * @this {THIS}\n     * @param {?=} value New width for the overlay\n     * @return {THIS}\n     */\n    width(value = '') {\n        if ((/** @type {?} */ (this))._overlayRef) {\n            (/** @type {?} */ (this))._overlayRef.updateSize({ width: value });\n        }\n        else {\n            (/** @type {?} */ (this))._width = value;\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * \\@breaking-change 8.0.0\n     * @template THIS\n     * @this {THIS}\n     * @param {?=} value New height for the overlay\n     * @return {THIS}\n     */\n    height(value = '') {\n        if ((/** @type {?} */ (this))._overlayRef) {\n            (/** @type {?} */ (this))._overlayRef.updateSize({ height: value });\n        }\n        else {\n            (/** @type {?} */ (this))._height = value;\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @template THIS\n     * @this {THIS}\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {THIS}\n     */\n    centerHorizontally(offset = '') {\n        (/** @type {?} */ (this)).left(offset);\n        (/** @type {?} */ (this))._justifyContent = 'center';\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @template THIS\n     * @this {THIS}\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {THIS}\n     */\n    centerVertically(offset = '') {\n        (/** @type {?} */ (this)).top(offset);\n        (/** @type {?} */ (this))._alignItems = 'center';\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     * @return {?}\n     */\n    apply() {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef || !this._overlayRef.hasAttached()) {\n            return;\n        }\n        /** @type {?} */\n        const styles = this._overlayRef.overlayElement.style;\n        /** @type {?} */\n        const parentStyles = this._overlayRef.hostElement.style;\n        /** @type {?} */\n        const config = this._overlayRef.getConfig();\n        styles.position = this._cssPosition;\n        styles.marginLeft = config.width === '100%' ? '0' : this._leftOffset;\n        styles.marginTop = config.height === '100%' ? '0' : this._topOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        if (config.width === '100%') {\n            parentStyles.justifyContent = 'flex-start';\n        }\n        else if (this._justifyContent === 'center') {\n            parentStyles.justifyContent = 'center';\n        }\n        else if (this._overlayRef.getConfig().direction === 'rtl') {\n            // In RTL the browser will invert `flex-start` and `flex-end` automatically, but we\n            // don't want that because our positioning is explicitly `left` and `right`, hence\n            // why we do another inversion to ensure that the overlay stays in the same position.\n            // TODO: reconsider this if we add `start` and `end` methods.\n            if (this._justifyContent === 'flex-start') {\n                parentStyles.justifyContent = 'flex-end';\n            }\n            else if (this._justifyContent === 'flex-end') {\n                parentStyles.justifyContent = 'flex-start';\n            }\n        }\n        else {\n            parentStyles.justifyContent = this._justifyContent;\n        }\n        parentStyles.alignItems = config.height === '100%' ? 'flex-start' : this._alignItems;\n    }\n    /**\n     * Cleans up the DOM changes from the position strategy.\n     * \\@docs-private\n     * @return {?}\n     */\n    dispose() {\n        if (this._isDisposed || !this._overlayRef) {\n            return;\n        }\n        /** @type {?} */\n        const styles = this._overlayRef.overlayElement.style;\n        /** @type {?} */\n        const parent = this._overlayRef.hostElement;\n        /** @type {?} */\n        const parentStyles = parent.style;\n        parent.classList.remove(wrapperClass);\n        parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop =\n            styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = '';\n        this._overlayRef = (/** @type {?} */ (null));\n        this._isDisposed = true;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Builder for overlay position strategy.\n */\nclass OverlayPositionBuilder {\n    /**\n     * @param {?} _viewportRuler\n     * @param {?} _document\n     * @param {?} _platform\n     * @param {?} _overlayContainer\n     */\n    constructor(_viewportRuler, _document, _platform, _overlayContainer) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        this._platform = _platform;\n        this._overlayContainer = _overlayContainer;\n    }\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    global() {\n        return new GlobalPositionStrategy();\n    }\n    /**\n     * Creates a relative position strategy.\n     * @deprecated Use `flexibleConnectedTo` instead.\n     * \\@breaking-change 8.0.0\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    connectedTo(elementRef, originPos, overlayPos) {\n        return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n    }\n    /**\n     * Creates a flexible position strategy.\n     * @param {?} origin Origin relative to which to position the overlay.\n     * @return {?}\n     */\n    flexibleConnectedTo(origin) {\n        return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n    }\n}\nOverlayPositionBuilder.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nOverlayPositionBuilder.ctorParameters = () => [\n    { type: ViewportRuler },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: Platform },\n    { type: OverlayContainer }\n];\n/** @nocollapse */ OverlayPositionBuilder.ngInjectableDef = ɵɵdefineInjectable({ factory: function OverlayPositionBuilder_Factory() { return new OverlayPositionBuilder(ɵɵinject(ViewportRuler), ɵɵinject(DOCUMENT), ɵɵinject(Platform), ɵɵinject(OverlayContainer)); }, token: OverlayPositionBuilder, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Next overlay unique ID.\n * @type {?}\n */\nlet nextUniqueId = 0;\n// Note that Overlay is *not* scoped to the app root because the ComponentFactoryResolver\n// it needs is different based on where OverlayModule is imported.\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nclass Overlay {\n    /**\n     * @param {?} scrollStrategies\n     * @param {?} _overlayContainer\n     * @param {?} _componentFactoryResolver\n     * @param {?} _positionBuilder\n     * @param {?} _keyboardDispatcher\n     * @param {?} _injector\n     * @param {?} _ngZone\n     * @param {?} _document\n     * @param {?} _directionality\n     * @param {?=} _location\n     */\n    constructor(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, _location) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._directionality = _directionality;\n        this._location = _location;\n    }\n    /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    create(config) {\n        /** @type {?} */\n        const host = this._createHostElement();\n        /** @type {?} */\n        const pane = this._createPaneElement(host);\n        /** @type {?} */\n        const portalOutlet = this._createPortalOutlet(pane);\n        /** @type {?} */\n        const overlayConfig = new OverlayConfig(config);\n        overlayConfig.direction = overlayConfig.direction || this._directionality.value;\n        return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location);\n    }\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    position() {\n        return this._positionBuilder;\n    }\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @private\n     * @param {?} host\n     * @return {?} Newly-created pane element\n     */\n    _createPaneElement(host) {\n        /** @type {?} */\n        const pane = this._document.createElement('div');\n        pane.id = `cdk-overlay-${nextUniqueId++}`;\n        pane.classList.add('cdk-overlay-pane');\n        host.appendChild(pane);\n        return pane;\n    }\n    /**\n     * Creates the host element that wraps around an overlay\n     * and can be used for advanced positioning.\n     * @private\n     * @return {?} Newly-create host element.\n     */\n    _createHostElement() {\n        /** @type {?} */\n        const host = this._document.createElement('div');\n        this._overlayContainer.getContainerElement().appendChild(host);\n        return host;\n    }\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @private\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    _createPortalOutlet(pane) {\n        // We have to resolve the ApplicationRef later in order to allow people\n        // to use overlay-based providers during app initialization.\n        if (!this._appRef) {\n            this._appRef = this._injector.get(ApplicationRef);\n        }\n        return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n    }\n}\nOverlay.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nOverlay.ctorParameters = () => [\n    { type: ScrollStrategyOptions },\n    { type: OverlayContainer },\n    { type: ComponentFactoryResolver },\n    { type: OverlayPositionBuilder },\n    { type: OverlayKeyboardDispatcher },\n    { type: Injector },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: Directionality },\n    { type: Location, decorators: [{ type: Optional }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n * @type {?}\n */\nconst defaultPositionList = [\n    {\n        originX: 'start',\n        originY: 'bottom',\n        overlayX: 'start',\n        overlayY: 'top'\n    },\n    {\n        originX: 'start',\n        originY: 'top',\n        overlayX: 'start',\n        overlayY: 'bottom'\n    },\n    {\n        originX: 'end',\n        originY: 'top',\n        overlayX: 'end',\n        overlayY: 'bottom'\n    },\n    {\n        originX: 'end',\n        originY: 'bottom',\n        overlayX: 'end',\n        overlayY: 'top'\n    }\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n * @type {?}\n */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('cdk-connected-overlay-scroll-strategy');\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nclass CdkOverlayOrigin {\n    /**\n     * @param {?} elementRef\n     */\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n    }\n}\nCdkOverlayOrigin.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                exportAs: 'cdkOverlayOrigin',\n            },] },\n];\n/** @nocollapse */\nCdkOverlayOrigin.ctorParameters = () => [\n    { type: ElementRef }\n];\n/**\n * Directive to facilitate declarative creation of an\n * Overlay using a FlexibleConnectedPositionStrategy.\n */\nclass CdkConnectedOverlay {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    /**\n     * @param {?} _overlay\n     * @param {?} templateRef\n     * @param {?} viewContainerRef\n     * @param {?} scrollStrategyFactory\n     * @param {?} _dir\n     */\n    constructor(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {\n        this._overlay = _overlay;\n        this._dir = _dir;\n        this._hasBackdrop = false;\n        this._lockPosition = false;\n        this._growAfterOpen = false;\n        this._flexibleDimensions = false;\n        this._push = false;\n        this._backdropSubscription = Subscription.EMPTY;\n        /**\n         * Margin between the overlay and the viewport edges.\n         */\n        this.viewportMargin = 0;\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new EventEmitter();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new EventEmitter();\n        /**\n         * Emits when there are keyboard events that are targeted at the overlay.\n         */\n        this.overlayKeydown = new EventEmitter();\n        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n        this._scrollStrategyFactory = scrollStrategyFactory;\n        this.scrollStrategy = this._scrollStrategyFactory();\n    }\n    /**\n     * The offset in pixels for the overlay connection point on the x-axis\n     * @return {?}\n     */\n    get offsetX() { return this._offsetX; }\n    /**\n     * @param {?} offsetX\n     * @return {?}\n     */\n    set offsetX(offsetX) {\n        this._offsetX = offsetX;\n        if (this._position) {\n            this._updatePositionStrategy(this._position);\n        }\n    }\n    /**\n     * The offset in pixels for the overlay connection point on the y-axis\n     * @return {?}\n     */\n    get offsetY() { return this._offsetY; }\n    /**\n     * @param {?} offsetY\n     * @return {?}\n     */\n    set offsetY(offsetY) {\n        this._offsetY = offsetY;\n        if (this._position) {\n            this._updatePositionStrategy(this._position);\n        }\n    }\n    /**\n     * Whether or not the overlay should attach a backdrop.\n     * @return {?}\n     */\n    get hasBackdrop() { return this._hasBackdrop; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set hasBackdrop(value) { this._hasBackdrop = coerceBooleanProperty(value); }\n    /**\n     * Whether or not the overlay should be locked when scrolling.\n     * @return {?}\n     */\n    get lockPosition() { return this._lockPosition; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set lockPosition(value) { this._lockPosition = coerceBooleanProperty(value); }\n    /**\n     * Whether the overlay's width and height can be constrained to fit within the viewport.\n     * @return {?}\n     */\n    get flexibleDimensions() { return this._flexibleDimensions; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set flexibleDimensions(value) {\n        this._flexibleDimensions = coerceBooleanProperty(value);\n    }\n    /**\n     * Whether the overlay can grow after the initial open when flexible positioning is turned on.\n     * @return {?}\n     */\n    get growAfterOpen() { return this._growAfterOpen; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set growAfterOpen(value) { this._growAfterOpen = coerceBooleanProperty(value); }\n    /**\n     * Whether the overlay can be pushed on-screen if none of the provided positions fit.\n     * @return {?}\n     */\n    get push() { return this._push; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set push(value) { this._push = coerceBooleanProperty(value); }\n    /**\n     * The associated overlay reference.\n     * @return {?}\n     */\n    get overlayRef() {\n        return this._overlayRef;\n    }\n    /**\n     * The element's layout direction.\n     * @return {?}\n     */\n    get dir() {\n        return this._dir ? this._dir.value : 'ltr';\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n        this._backdropSubscription.unsubscribe();\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (this._position) {\n            this._updatePositionStrategy(this._position);\n            this._overlayRef.updateSize({\n                width: this.width,\n                minWidth: this.minWidth,\n                height: this.height,\n                minHeight: this.minHeight,\n            });\n            if (changes['origin'] && this.open) {\n                this._position.apply();\n            }\n        }\n        if (changes['open']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    }\n    /**\n     * Creates an overlay\n     * @private\n     * @return {?}\n     */\n    _createOverlay() {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        this._overlayRef = this._overlay.create(this._buildConfig());\n        this._overlayRef.keydownEvents().subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            this.overlayKeydown.next(event);\n            if (event.keyCode === ESCAPE && !hasModifierKey(event)) {\n                event.preventDefault();\n                this._detachOverlay();\n            }\n        }));\n    }\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @private\n     * @return {?}\n     */\n    _buildConfig() {\n        /** @type {?} */\n        const positionStrategy = this._position = this._createPositionStrategy();\n        /** @type {?} */\n        const overlayConfig = new OverlayConfig({\n            direction: this._dir,\n            positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        if (this.panelClass) {\n            overlayConfig.panelClass = this.panelClass;\n        }\n        return overlayConfig;\n    }\n    /**\n     * Updates the state of a position strategy, based on the values of the directive inputs.\n     * @private\n     * @param {?} positionStrategy\n     * @return {?}\n     */\n    _updatePositionStrategy(positionStrategy) {\n        /** @type {?} */\n        const positions = this.positions.map((/**\n         * @param {?} currentPosition\n         * @return {?}\n         */\n        currentPosition => ({\n            originX: currentPosition.originX,\n            originY: currentPosition.originY,\n            overlayX: currentPosition.overlayX,\n            overlayY: currentPosition.overlayY,\n            offsetX: currentPosition.offsetX || this.offsetX,\n            offsetY: currentPosition.offsetY || this.offsetY,\n            panelClass: currentPosition.panelClass || undefined,\n        })));\n        return positionStrategy\n            .setOrigin(this.origin.elementRef)\n            .withPositions(positions)\n            .withFlexibleDimensions(this.flexibleDimensions)\n            .withPush(this.push)\n            .withGrowAfterOpen(this.growAfterOpen)\n            .withViewportMargin(this.viewportMargin)\n            .withLockedPosition(this.lockPosition);\n    }\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @private\n     * @return {?}\n     */\n    _createPositionStrategy() {\n        /** @type {?} */\n        const strategy = this._overlay.position().flexibleConnectedTo(this.origin.elementRef);\n        this._updatePositionStrategy(strategy);\n        strategy.positionChanges.subscribe((/**\n         * @param {?} p\n         * @return {?}\n         */\n        p => this.positionChange.emit(p)));\n        return strategy;\n    }\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @private\n     * @return {?}\n     */\n    _attachOverlay() {\n        if (!this._overlayRef) {\n            this._createOverlay();\n        }\n        else {\n            // Update the overlay size, in case the directive's inputs have changed\n            this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;\n        }\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n            this.attach.emit();\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe((/**\n             * @param {?} event\n             * @return {?}\n             */\n            event => {\n                this.backdropClick.emit(event);\n            }));\n        }\n        else {\n            this._backdropSubscription.unsubscribe();\n        }\n    }\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @private\n     * @return {?}\n     */\n    _detachOverlay() {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this.detach.emit();\n        }\n        this._backdropSubscription.unsubscribe();\n    }\n}\nCdkConnectedOverlay.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                exportAs: 'cdkConnectedOverlay'\n            },] },\n];\n/** @nocollapse */\nCdkConnectedOverlay.ctorParameters = () => [\n    { type: Overlay },\n    { type: TemplateRef },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] }] },\n    { type: Directionality, decorators: [{ type: Optional }] }\n];\nCdkConnectedOverlay.propDecorators = {\n    origin: [{ type: Input, args: ['cdkConnectedOverlayOrigin',] }],\n    positions: [{ type: Input, args: ['cdkConnectedOverlayPositions',] }],\n    offsetX: [{ type: Input, args: ['cdkConnectedOverlayOffsetX',] }],\n    offsetY: [{ type: Input, args: ['cdkConnectedOverlayOffsetY',] }],\n    width: [{ type: Input, args: ['cdkConnectedOverlayWidth',] }],\n    height: [{ type: Input, args: ['cdkConnectedOverlayHeight',] }],\n    minWidth: [{ type: Input, args: ['cdkConnectedOverlayMinWidth',] }],\n    minHeight: [{ type: Input, args: ['cdkConnectedOverlayMinHeight',] }],\n    backdropClass: [{ type: Input, args: ['cdkConnectedOverlayBackdropClass',] }],\n    panelClass: [{ type: Input, args: ['cdkConnectedOverlayPanelClass',] }],\n    viewportMargin: [{ type: Input, args: ['cdkConnectedOverlayViewportMargin',] }],\n    scrollStrategy: [{ type: Input, args: ['cdkConnectedOverlayScrollStrategy',] }],\n    open: [{ type: Input, args: ['cdkConnectedOverlayOpen',] }],\n    hasBackdrop: [{ type: Input, args: ['cdkConnectedOverlayHasBackdrop',] }],\n    lockPosition: [{ type: Input, args: ['cdkConnectedOverlayLockPosition',] }],\n    flexibleDimensions: [{ type: Input, args: ['cdkConnectedOverlayFlexibleDimensions',] }],\n    growAfterOpen: [{ type: Input, args: ['cdkConnectedOverlayGrowAfterOpen',] }],\n    push: [{ type: Input, args: ['cdkConnectedOverlayPush',] }],\n    backdropClick: [{ type: Output }],\n    positionChange: [{ type: Output }],\n    attach: [{ type: Output }],\n    detach: [{ type: Output }],\n    overlayKeydown: [{ type: Output }]\n};\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return (/**\n     * @return {?}\n     */\n    () => overlay.scrollStrategies.reposition());\n}\n/**\n * \\@docs-private\n * @type {?}\n */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass OverlayModule {\n}\nOverlayModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [BidiModule, PortalModule, ScrollingModule],\n                exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule],\n                declarations: [CdkConnectedOverlay, CdkOverlayOrigin],\n                providers: [\n                    Overlay,\n                    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n                ],\n            },] },\n];\n/**\n * @deprecated Use `OverlayModule` instead.\n * \\@breaking-change 8.0.0\n * \\@docs-private\n * @type {?}\n */\nconst OVERLAY_PROVIDERS = [\n    Overlay,\n    OverlayPositionBuilder,\n    OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nclass FullscreenOverlayContainer extends OverlayContainer {\n    /**\n     * @param {?} _document\n     */\n    constructor(_document) {\n        super(_document);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        if (this._fullScreenEventName && this._fullScreenListener) {\n            this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);\n        }\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    _createContainer() {\n        super._createContainer();\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener((/**\n         * @return {?}\n         */\n        () => this._adjustParentForFullscreenChange()));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _adjustParentForFullscreenChange() {\n        if (!this._containerElement) {\n            return;\n        }\n        /** @type {?} */\n        const fullscreenElement = this.getFullscreenElement();\n        /** @type {?} */\n        const parent = fullscreenElement || this._document.body;\n        parent.appendChild(this._containerElement);\n    }\n    /**\n     * @private\n     * @param {?} fn\n     * @return {?}\n     */\n    _addFullscreenChangeListener(fn) {\n        /** @type {?} */\n        const eventName = this._getEventName();\n        if (eventName) {\n            if (this._fullScreenListener) {\n                this._document.removeEventListener(eventName, this._fullScreenListener);\n            }\n            this._document.addEventListener(eventName, fn);\n            this._fullScreenListener = fn;\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _getEventName() {\n        if (!this._fullScreenEventName) {\n            /** @type {?} */\n            const _document = (/** @type {?} */ (this._document));\n            if (_document.fullscreenEnabled) {\n                this._fullScreenEventName = 'fullscreenchange';\n            }\n            else if (_document.webkitFullscreenEnabled) {\n                this._fullScreenEventName = 'webkitfullscreenchange';\n            }\n            else if (_document.mozFullScreenEnabled) {\n                this._fullScreenEventName = 'mozfullscreenchange';\n            }\n            else if (_document.msFullscreenEnabled) {\n                this._fullScreenEventName = 'MSFullscreenChange';\n            }\n        }\n        return this._fullScreenEventName;\n    }\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    getFullscreenElement() {\n        /** @type {?} */\n        const _document = (/** @type {?} */ (this._document));\n        return _document.fullscreenElement ||\n            _document.webkitFullscreenElement ||\n            _document.mozFullScreenElement ||\n            _document.msFullscreenElement ||\n            null;\n    }\n}\nFullscreenOverlayContainer.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nFullscreenOverlayContainer.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n/** @nocollapse */ FullscreenOverlayContainer.ngInjectableDef = ɵɵdefineInjectable({ factory: function FullscreenOverlayContainer_Factory() { return new FullscreenOverlayContainer(ɵɵinject(DOCUMENT)); }, token: FullscreenOverlayContainer, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { Overlay, OverlayContainer, CdkOverlayOrigin, CdkConnectedOverlay, FullscreenOverlayContainer, OverlayRef, OverlayKeyboardDispatcher, OverlayPositionBuilder, GlobalPositionStrategy, ConnectedPositionStrategy, FlexibleConnectedPositionStrategy, OverlayConfig, validateVerticalPosition, validateHorizontalPosition, ConnectionPositionPair, ScrollingVisibility, ConnectedOverlayPositionChange, ScrollStrategyOptions, RepositionScrollStrategy, CloseScrollStrategy, NoopScrollStrategy, BlockScrollStrategy, OverlayModule, OVERLAY_PROVIDERS, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER as ɵg, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY as ɵf, OVERLAY_CONTAINER_PROVIDER as ɵb, OVERLAY_CONTAINER_PROVIDER_FACTORY as ɵa, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY as ɵc, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER as ɵe, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY as ɵd };\n//# sourceMappingURL=overlay.js.map\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { animate, keyframes, state, style, transition, trigger } from '@angular/animations';\nimport { AriaDescriber, FocusMonitor, A11yModule } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\nimport { BreakpointObserver, Breakpoints } from '@angular/cdk/layout';\nimport { Overlay, OverlayModule } from '@angular/cdk/overlay';\nimport { Platform } from '@angular/cdk/platform';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { ScrollDispatcher } from '@angular/cdk/scrolling';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, ElementRef, Inject, InjectionToken, Input, NgZone, Optional, ViewContainerRef, ViewEncapsulation, NgModule } from '@angular/core';\nimport { HAMMER_LOADER, HAMMER_GESTURE_CONFIG } from '@angular/platform-browser';\nimport { Subject } from 'rxjs';\nimport { take, takeUntil } from 'rxjs/operators';\nimport { CommonModule } from '@angular/common';\nimport { GestureConfig, MatCommonModule } from '@angular/material/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Animations used by MatTooltip.\n * \\@docs-private\n * @type {?}\n */\nconst matTooltipAnimations = {\n    /**\n     * Animation that transitions a tooltip in and out.\n     */\n    tooltipState: trigger('state', [\n        state('initial, void, hidden', style({ opacity: 0, transform: 'scale(0)' })),\n        state('visible', style({ transform: 'scale(1)' })),\n        transition('* => visible', animate('200ms cubic-bezier(0, 0, 0.2, 1)', keyframes([\n            style({ opacity: 0, transform: 'scale(0)', offset: 0 }),\n            style({ opacity: 0.5, transform: 'scale(0.99)', offset: 0.5 }),\n            style({ opacity: 1, transform: 'scale(1)', offset: 1 })\n        ]))),\n        transition('* => hidden', animate('100ms cubic-bezier(0, 0, 0.2, 1)', style({ opacity: 0 }))),\n    ])\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Time in ms to throttle repositioning after scroll events.\n * @type {?}\n */\nconst SCROLL_THROTTLE_MS = 20;\n/**\n * CSS class that will be attached to the overlay panel.\n * @type {?}\n */\nconst TOOLTIP_PANEL_CLASS = 'mat-tooltip-panel';\n/**\n * Creates an error to be thrown if the user supplied an invalid tooltip position.\n * \\@docs-private\n * @param {?} position\n * @return {?}\n */\nfunction getMatTooltipInvalidPositionError(position) {\n    return Error(`Tooltip position \"${position}\" is invalid.`);\n}\n/**\n * Injection token that determines the scroll handling while a tooltip is visible.\n * @type {?}\n */\nconst MAT_TOOLTIP_SCROLL_STRATEGY = new InjectionToken('mat-tooltip-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay) {\n    return (/**\n     * @return {?}\n     */\n    () => overlay.scrollStrategies.reposition({ scrollThrottle: SCROLL_THROTTLE_MS }));\n}\n/**\n * \\@docs-private\n * @type {?}\n */\nconst MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_TOOLTIP_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY,\n};\n/**\n * Injection token to be used to override the default options for `matTooltip`.\n * @type {?}\n */\nconst MAT_TOOLTIP_DEFAULT_OPTIONS = new InjectionToken('mat-tooltip-default-options', {\n    providedIn: 'root',\n    factory: MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        showDelay: 0,\n        hideDelay: 0,\n        touchendHideDelay: 1500,\n    };\n}\n/**\n * Directive that attaches a material design tooltip to the host element. Animates the showing and\n * hiding of a tooltip provided position (defaults to below the element).\n *\n * https://material.io/design/components/tooltips.html\n */\nclass MatTooltip {\n    /**\n     * @param {?} _overlay\n     * @param {?} _elementRef\n     * @param {?} _scrollDispatcher\n     * @param {?} _viewContainerRef\n     * @param {?} _ngZone\n     * @param {?} platform\n     * @param {?} _ariaDescriber\n     * @param {?} _focusMonitor\n     * @param {?} scrollStrategy\n     * @param {?} _dir\n     * @param {?} _defaultOptions\n     * @param {?=} hammerLoader\n     */\n    constructor(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, platform, _ariaDescriber, _focusMonitor, scrollStrategy, _dir, _defaultOptions, hammerLoader) {\n        this._overlay = _overlay;\n        this._elementRef = _elementRef;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewContainerRef = _viewContainerRef;\n        this._ngZone = _ngZone;\n        this._ariaDescriber = _ariaDescriber;\n        this._focusMonitor = _focusMonitor;\n        this._dir = _dir;\n        this._defaultOptions = _defaultOptions;\n        this._position = 'below';\n        this._disabled = false;\n        /**\n         * The default delay in ms before showing the tooltip after show is called\n         */\n        this.showDelay = this._defaultOptions.showDelay;\n        /**\n         * The default delay in ms before hiding the tooltip after hide is called\n         */\n        this.hideDelay = this._defaultOptions.hideDelay;\n        this._message = '';\n        this._manualListeners = new Map();\n        /**\n         * Emits when the component is destroyed.\n         */\n        this._destroyed = new Subject();\n        this._scrollStrategy = scrollStrategy;\n        /** @type {?} */\n        const element = _elementRef.nativeElement;\n        /** @type {?} */\n        const hasGestures = typeof window === 'undefined' || ((/** @type {?} */ (window))).Hammer || hammerLoader;\n        // The mouse events shouldn't be bound on mobile devices, because they can prevent the\n        // first tap from firing its click event or can cause the tooltip to open for clicks.\n        if (!platform.IOS && !platform.ANDROID) {\n            this._manualListeners\n                .set('mouseenter', (/**\n             * @return {?}\n             */\n            () => this.show()))\n                .set('mouseleave', (/**\n             * @return {?}\n             */\n            () => this.hide()));\n        }\n        else if (!hasGestures) {\n            // If Hammerjs isn't loaded, fall back to showing on `touchstart`, otherwise\n            // there's no way for the user to trigger the tooltip on a touch device.\n            this._manualListeners.set('touchstart', (/**\n             * @return {?}\n             */\n            () => this.show()));\n        }\n        this._manualListeners.forEach((/**\n         * @param {?} listener\n         * @param {?} event\n         * @return {?}\n         */\n        (listener, event) => element.addEventListener(event, listener)));\n        _focusMonitor.monitor(_elementRef).pipe(takeUntil(this._destroyed)).subscribe((/**\n         * @param {?} origin\n         * @return {?}\n         */\n        origin => {\n            // Note that the focus monitor runs outside the Angular zone.\n            if (!origin) {\n                _ngZone.run((/**\n                 * @return {?}\n                 */\n                () => this.hide(0)));\n            }\n            else if (origin === 'keyboard') {\n                _ngZone.run((/**\n                 * @return {?}\n                 */\n                () => this.show()));\n            }\n        }));\n        if (_defaultOptions && _defaultOptions.position) {\n            this.position = _defaultOptions.position;\n        }\n    }\n    /**\n     * Allows the user to define the position of the tooltip relative to the parent element\n     * @return {?}\n     */\n    get position() { return this._position; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set position(value) {\n        if (value !== this._position) {\n            this._position = value;\n            if (this._overlayRef) {\n                this._updatePosition();\n                if (this._tooltipInstance) {\n                    (/** @type {?} */ (this._tooltipInstance)).show(0);\n                }\n                this._overlayRef.updatePosition();\n            }\n        }\n    }\n    /**\n     * Disables the display of the tooltip.\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        // If tooltip is disabled, hide immediately.\n        if (this._disabled) {\n            this.hide(0);\n        }\n    }\n    /**\n     * The message to be displayed in the tooltip\n     * @return {?}\n     */\n    get message() { return this._message; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set message(value) {\n        this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message);\n        // If the message is not a string (e.g. number), convert it to a string and trim it.\n        this._message = value != null ? `${value}`.trim() : '';\n        if (!this._message && this._isTooltipVisible()) {\n            this.hide(0);\n        }\n        else {\n            this._updateTooltipMessage();\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                // The `AriaDescriber` has some functionality that avoids adding a description if it's the\n                // same as the `aria-label` of an element, however we can't know whether the tooltip trigger\n                // has a data-bound `aria-label` or when it'll be set for the first time. We can avoid the\n                // issue by deferring the description by a tick so Angular has time to set the `aria-label`.\n                Promise.resolve().then((/**\n                 * @return {?}\n                 */\n                () => {\n                    this._ariaDescriber.describe(this._elementRef.nativeElement, this.message);\n                }));\n            }));\n        }\n    }\n    /**\n     * Classes to be passed to the tooltip. Supports the same syntax as `ngClass`.\n     * @return {?}\n     */\n    get tooltipClass() { return this._tooltipClass; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set tooltipClass(value) {\n        this._tooltipClass = value;\n        if (this._tooltipInstance) {\n            this._setTooltipClass(this._tooltipClass);\n        }\n    }\n    /**\n     * Setup styling-specific things\n     * @return {?}\n     */\n    ngOnInit() {\n        /** @type {?} */\n        const element = this._elementRef.nativeElement;\n        /** @type {?} */\n        const elementStyle = (/** @type {?} */ (element.style));\n        if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {\n            // When we bind a gesture event on an element (in this case `longpress`), HammerJS\n            // will add some inline styles by default, including `user-select: none`. This is\n            // problematic on iOS and in Safari, because it will prevent users from typing in inputs.\n            // Since `user-select: none` is not needed for the `longpress` event and can cause unexpected\n            // behavior for text fields, we always clear the `user-select` to avoid such issues.\n            elementStyle.webkitUserSelect = elementStyle.userSelect = elementStyle.msUserSelect = '';\n        }\n        // Hammer applies `-webkit-user-drag: none` on all elements by default,\n        // which breaks the native drag&drop. If the consumer explicitly made\n        // the element draggable, clear the `-webkit-user-drag`.\n        if (element.draggable && elementStyle.webkitUserDrag === 'none') {\n            elementStyle.webkitUserDrag = '';\n        }\n    }\n    /**\n     * Dispose the tooltip when destroyed.\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n            this._tooltipInstance = null;\n        }\n        // Clean up the event listeners set in the constructor\n        this._manualListeners.forEach((/**\n         * @param {?} listener\n         * @param {?} event\n         * @return {?}\n         */\n        (listener, event) => {\n            this._elementRef.nativeElement.removeEventListener(event, listener);\n        }));\n        this._manualListeners.clear();\n        this._destroyed.next();\n        this._destroyed.complete();\n        this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this.message);\n        this._focusMonitor.stopMonitoring(this._elementRef);\n    }\n    /**\n     * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input\n     * @param {?=} delay\n     * @return {?}\n     */\n    show(delay = this.showDelay) {\n        if (this.disabled || !this.message || (this._isTooltipVisible() &&\n            !(/** @type {?} */ (this._tooltipInstance))._showTimeoutId && !(/** @type {?} */ (this._tooltipInstance))._hideTimeoutId)) {\n            return;\n        }\n        /** @type {?} */\n        const overlayRef = this._createOverlay();\n        this._detach();\n        this._portal = this._portal || new ComponentPortal(TooltipComponent, this._viewContainerRef);\n        this._tooltipInstance = overlayRef.attach(this._portal).instance;\n        this._tooltipInstance.afterHidden()\n            .pipe(takeUntil(this._destroyed))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => this._detach()));\n        this._setTooltipClass(this._tooltipClass);\n        this._updateTooltipMessage();\n        (/** @type {?} */ (this._tooltipInstance)).show(delay);\n    }\n    /**\n     * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input\n     * @param {?=} delay\n     * @return {?}\n     */\n    hide(delay = this.hideDelay) {\n        if (this._tooltipInstance) {\n            this._tooltipInstance.hide(delay);\n        }\n    }\n    /**\n     * Shows/hides the tooltip\n     * @return {?}\n     */\n    toggle() {\n        this._isTooltipVisible() ? this.hide() : this.show();\n    }\n    /**\n     * Returns true if the tooltip is currently visible to the user\n     * @return {?}\n     */\n    _isTooltipVisible() {\n        return !!this._tooltipInstance && this._tooltipInstance.isVisible();\n    }\n    /**\n     * Handles the keydown events on the host element.\n     * @param {?} e\n     * @return {?}\n     */\n    _handleKeydown(e) {\n        if (this._isTooltipVisible() && e.keyCode === ESCAPE && !hasModifierKey(e)) {\n            e.preventDefault();\n            e.stopPropagation();\n            this.hide(0);\n        }\n    }\n    /**\n     * Handles the touchend events on the host element.\n     * @return {?}\n     */\n    _handleTouchend() {\n        this.hide(this._defaultOptions.touchendHideDelay);\n    }\n    /**\n     * Create the overlay config and position strategy\n     * @private\n     * @return {?}\n     */\n    _createOverlay() {\n        if (this._overlayRef) {\n            return this._overlayRef;\n        }\n        /** @type {?} */\n        const scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);\n        // Create connected position strategy that listens for scroll events to reposition.\n        /** @type {?} */\n        const strategy = this._overlay.position()\n            .flexibleConnectedTo(this._elementRef)\n            .withTransformOriginOn('.mat-tooltip')\n            .withFlexibleDimensions(false)\n            .withViewportMargin(8)\n            .withScrollableContainers(scrollableAncestors);\n        strategy.positionChanges.pipe(takeUntil(this._destroyed)).subscribe((/**\n         * @param {?} change\n         * @return {?}\n         */\n        change => {\n            if (this._tooltipInstance) {\n                if (change.scrollableViewProperties.isOverlayClipped && this._tooltipInstance.isVisible()) {\n                    // After position changes occur and the overlay is clipped by\n                    // a parent scrollable then close the tooltip.\n                    this._ngZone.run((/**\n                     * @return {?}\n                     */\n                    () => this.hide(0)));\n                }\n            }\n        }));\n        this._overlayRef = this._overlay.create({\n            direction: this._dir,\n            positionStrategy: strategy,\n            panelClass: TOOLTIP_PANEL_CLASS,\n            scrollStrategy: this._scrollStrategy()\n        });\n        this._updatePosition();\n        this._overlayRef.detachments()\n            .pipe(takeUntil(this._destroyed))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => this._detach()));\n        return this._overlayRef;\n    }\n    /**\n     * Detaches the currently-attached tooltip.\n     * @private\n     * @return {?}\n     */\n    _detach() {\n        if (this._overlayRef && this._overlayRef.hasAttached()) {\n            this._overlayRef.detach();\n        }\n        this._tooltipInstance = null;\n    }\n    /**\n     * Updates the position of the current tooltip.\n     * @private\n     * @return {?}\n     */\n    _updatePosition() {\n        /** @type {?} */\n        const position = (/** @type {?} */ ((/** @type {?} */ (this._overlayRef)).getConfig().positionStrategy));\n        /** @type {?} */\n        const origin = this._getOrigin();\n        /** @type {?} */\n        const overlay = this._getOverlayPosition();\n        position.withPositions([\n            Object.assign({}, origin.main, overlay.main),\n            Object.assign({}, origin.fallback, overlay.fallback)\n        ]);\n    }\n    /**\n     * Returns the origin position and a fallback position based on the user's position preference.\n     * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\n     * @return {?}\n     */\n    _getOrigin() {\n        /** @type {?} */\n        const isLtr = !this._dir || this._dir.value == 'ltr';\n        /** @type {?} */\n        const position = this.position;\n        /** @type {?} */\n        let originPosition;\n        if (position == 'above' || position == 'below') {\n            originPosition = { originX: 'center', originY: position == 'above' ? 'top' : 'bottom' };\n        }\n        else if (position == 'before' ||\n            (position == 'left' && isLtr) ||\n            (position == 'right' && !isLtr)) {\n            originPosition = { originX: 'start', originY: 'center' };\n        }\n        else if (position == 'after' ||\n            (position == 'right' && isLtr) ||\n            (position == 'left' && !isLtr)) {\n            originPosition = { originX: 'end', originY: 'center' };\n        }\n        else {\n            throw getMatTooltipInvalidPositionError(position);\n        }\n        const { x, y } = this._invertPosition(originPosition.originX, originPosition.originY);\n        return {\n            main: originPosition,\n            fallback: { originX: x, originY: y }\n        };\n    }\n    /**\n     * Returns the overlay position and a fallback position based on the user's preference\n     * @return {?}\n     */\n    _getOverlayPosition() {\n        /** @type {?} */\n        const isLtr = !this._dir || this._dir.value == 'ltr';\n        /** @type {?} */\n        const position = this.position;\n        /** @type {?} */\n        let overlayPosition;\n        if (position == 'above') {\n            overlayPosition = { overlayX: 'center', overlayY: 'bottom' };\n        }\n        else if (position == 'below') {\n            overlayPosition = { overlayX: 'center', overlayY: 'top' };\n        }\n        else if (position == 'before' ||\n            (position == 'left' && isLtr) ||\n            (position == 'right' && !isLtr)) {\n            overlayPosition = { overlayX: 'end', overlayY: 'center' };\n        }\n        else if (position == 'after' ||\n            (position == 'right' && isLtr) ||\n            (position == 'left' && !isLtr)) {\n            overlayPosition = { overlayX: 'start', overlayY: 'center' };\n        }\n        else {\n            throw getMatTooltipInvalidPositionError(position);\n        }\n        const { x, y } = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY);\n        return {\n            main: overlayPosition,\n            fallback: { overlayX: x, overlayY: y }\n        };\n    }\n    /**\n     * Updates the tooltip message and repositions the overlay according to the new message length\n     * @private\n     * @return {?}\n     */\n    _updateTooltipMessage() {\n        // Must wait for the message to be painted to the tooltip so that the overlay can properly\n        // calculate the correct positioning based on the size of the text.\n        if (this._tooltipInstance) {\n            this._tooltipInstance.message = this.message;\n            this._tooltipInstance._markForCheck();\n            this._ngZone.onMicrotaskEmpty.asObservable().pipe(take(1), takeUntil(this._destroyed)).subscribe((/**\n             * @return {?}\n             */\n            () => {\n                if (this._tooltipInstance) {\n                    (/** @type {?} */ (this._overlayRef)).updatePosition();\n                }\n            }));\n        }\n    }\n    /**\n     * Updates the tooltip class\n     * @private\n     * @param {?} tooltipClass\n     * @return {?}\n     */\n    _setTooltipClass(tooltipClass) {\n        if (this._tooltipInstance) {\n            this._tooltipInstance.tooltipClass = tooltipClass;\n            this._tooltipInstance._markForCheck();\n        }\n    }\n    /**\n     * Inverts an overlay position.\n     * @private\n     * @param {?} x\n     * @param {?} y\n     * @return {?}\n     */\n    _invertPosition(x, y) {\n        if (this.position === 'above' || this.position === 'below') {\n            if (y === 'top') {\n                y = 'bottom';\n            }\n            else if (y === 'bottom') {\n                y = 'top';\n            }\n        }\n        else {\n            if (x === 'end') {\n                x = 'start';\n            }\n            else if (x === 'start') {\n                x = 'end';\n            }\n        }\n        return { x, y };\n    }\n}\nMatTooltip.decorators = [\n    { type: Directive, args: [{\n                selector: '[matTooltip]',\n                exportAs: 'matTooltip',\n                host: {\n                    '(longpress)': 'show()',\n                    '(keydown)': '_handleKeydown($event)',\n                    '(touchend)': '_handleTouchend()',\n                },\n            },] },\n];\n/** @nocollapse */\nMatTooltip.ctorParameters = () => [\n    { type: Overlay },\n    { type: ElementRef },\n    { type: ScrollDispatcher },\n    { type: ViewContainerRef },\n    { type: NgZone },\n    { type: Platform },\n    { type: AriaDescriber },\n    { type: FocusMonitor },\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_TOOLTIP_SCROLL_STRATEGY,] }] },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_TOOLTIP_DEFAULT_OPTIONS,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [HAMMER_LOADER,] }] }\n];\nMatTooltip.propDecorators = {\n    position: [{ type: Input, args: ['matTooltipPosition',] }],\n    disabled: [{ type: Input, args: ['matTooltipDisabled',] }],\n    showDelay: [{ type: Input, args: ['matTooltipShowDelay',] }],\n    hideDelay: [{ type: Input, args: ['matTooltipHideDelay',] }],\n    message: [{ type: Input, args: ['matTooltip',] }],\n    tooltipClass: [{ type: Input, args: ['matTooltipClass',] }]\n};\n/**\n * Internal component that wraps the tooltip's content.\n * \\@docs-private\n */\nclass TooltipComponent {\n    /**\n     * @param {?} _changeDetectorRef\n     * @param {?} _breakpointObserver\n     */\n    constructor(_changeDetectorRef, _breakpointObserver) {\n        this._changeDetectorRef = _changeDetectorRef;\n        this._breakpointObserver = _breakpointObserver;\n        /**\n         * Property watched by the animation framework to show or hide the tooltip\n         */\n        this._visibility = 'initial';\n        /**\n         * Whether interactions on the page should close the tooltip\n         */\n        this._closeOnInteraction = false;\n        /**\n         * Subject for notifying that the tooltip has been hidden from the view\n         */\n        this._onHide = new Subject();\n        /**\n         * Stream that emits whether the user has a handset-sized display.\n         */\n        this._isHandset = this._breakpointObserver.observe(Breakpoints.Handset);\n    }\n    /**\n     * Shows the tooltip with an animation originating from the provided origin\n     * @param {?} delay Amount of milliseconds to the delay showing the tooltip.\n     * @return {?}\n     */\n    show(delay) {\n        // Cancel the delayed hide if it is scheduled\n        if (this._hideTimeoutId) {\n            clearTimeout(this._hideTimeoutId);\n            this._hideTimeoutId = null;\n        }\n        // Body interactions should cancel the tooltip if there is a delay in showing.\n        this._closeOnInteraction = true;\n        this._showTimeoutId = setTimeout((/**\n         * @return {?}\n         */\n        () => {\n            this._visibility = 'visible';\n            this._showTimeoutId = null;\n            // Mark for check so if any parent component has set the\n            // ChangeDetectionStrategy to OnPush it will be checked anyways\n            this._markForCheck();\n        }), delay);\n    }\n    /**\n     * Begins the animation to hide the tooltip after the provided delay in ms.\n     * @param {?} delay Amount of milliseconds to delay showing the tooltip.\n     * @return {?}\n     */\n    hide(delay) {\n        // Cancel the delayed show if it is scheduled\n        if (this._showTimeoutId) {\n            clearTimeout(this._showTimeoutId);\n            this._showTimeoutId = null;\n        }\n        this._hideTimeoutId = setTimeout((/**\n         * @return {?}\n         */\n        () => {\n            this._visibility = 'hidden';\n            this._hideTimeoutId = null;\n            // Mark for check so if any parent component has set the\n            // ChangeDetectionStrategy to OnPush it will be checked anyways\n            this._markForCheck();\n        }), delay);\n    }\n    /**\n     * Returns an observable that notifies when the tooltip has been hidden from view.\n     * @return {?}\n     */\n    afterHidden() {\n        return this._onHide.asObservable();\n    }\n    /**\n     * Whether the tooltip is being displayed.\n     * @return {?}\n     */\n    isVisible() {\n        return this._visibility === 'visible';\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._onHide.complete();\n    }\n    /**\n     * @return {?}\n     */\n    _animationStart() {\n        this._closeOnInteraction = false;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    _animationDone(event) {\n        /** @type {?} */\n        const toState = (/** @type {?} */ (event.toState));\n        if (toState === 'hidden' && !this.isVisible()) {\n            this._onHide.next();\n        }\n        if (toState === 'visible' || toState === 'hidden') {\n            this._closeOnInteraction = true;\n        }\n    }\n    /**\n     * Interactions on the HTML body should close the tooltip immediately as defined in the\n     * material design spec.\n     * https://material.io/design/components/tooltips.html#behavior\n     * @return {?}\n     */\n    _handleBodyInteraction() {\n        if (this._closeOnInteraction) {\n            this.hide(0);\n        }\n    }\n    /**\n     * Marks that the tooltip needs to be checked in the next change detection run.\n     * Mainly used for rendering the initial text before positioning a tooltip, which\n     * can be problematic in components with OnPush change detection.\n     * @return {?}\n     */\n    _markForCheck() {\n        this._changeDetectorRef.markForCheck();\n    }\n}\nTooltipComponent.decorators = [\n    { type: Component, args: [{selector: 'mat-tooltip-component',\n                template: \"<div class=\\\"mat-tooltip\\\" [ngClass]=\\\"tooltipClass\\\" [class.mat-tooltip-handset]=\\\"(_isHandset | async)?.matches\\\" [@state]=\\\"_visibility\\\" (@state.start)=\\\"_animationStart()\\\" (@state.done)=\\\"_animationDone($event)\\\">{{message}}</div>\",\n                styles: [\".mat-tooltip-panel{pointer-events:none!important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}@media (-ms-high-contrast:active){.mat-tooltip{outline:solid 1px}}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\"],\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                animations: [matTooltipAnimations.tooltipState],\n                host: {\n                    // Forces the element to have a layout in IE and Edge. This fixes issues where the element\n                    // won't be rendered if the animations are disabled or there is no web animations polyfill.\n                    '[style.zoom]': '_visibility === \"visible\" ? 1 : null',\n                    '(body:click)': 'this._handleBodyInteraction()',\n                    'aria-hidden': 'true',\n                }\n            },] },\n];\n/** @nocollapse */\nTooltipComponent.ctorParameters = () => [\n    { type: ChangeDetectorRef },\n    { type: BreakpointObserver }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatTooltipModule {\n}\nMatTooltipModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [\n                    A11yModule,\n                    CommonModule,\n                    OverlayModule,\n                    MatCommonModule,\n                ],\n                exports: [MatTooltip, TooltipComponent, MatCommonModule],\n                declarations: [MatTooltip, TooltipComponent],\n                entryComponents: [TooltipComponent],\n                providers: [\n                    MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER,\n                    { provide: HAMMER_GESTURE_CONFIG, useClass: GestureConfig },\n                ]\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { MatTooltipModule, getMatTooltipInvalidPositionError, MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY, MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY, SCROLL_THROTTLE_MS, TOOLTIP_PANEL_CLASS, MAT_TOOLTIP_SCROLL_STRATEGY, MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_TOOLTIP_DEFAULT_OPTIONS, MatTooltip, TooltipComponent, matTooltipAnimations };\n//# sourceMappingURL=tooltip.js.map\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Component, ChangeDetectionStrategy, ElementRef, Inject, Input, Output, EventEmitter, Optional, NgZone, ViewEncapsulation, ViewChild, InjectionToken, inject, NgModule } from '@angular/core';\nimport { fromEvent, Subscription } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\nimport { mixinColor, MatCommonModule } from '@angular/material/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Boilerplate for applying mixins to MatProgressBar.\n/**\n * \\@docs-private\n */\nclass MatProgressBarBase {\n    /**\n     * @param {?} _elementRef\n     */\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\n/** @type {?} */\nconst _MatProgressBarMixinBase = mixinColor(MatProgressBarBase, 'primary');\n/**\n * Injection token used to provide the current location to `MatProgressBar`.\n * Used to handle server-side rendering and to stub out during unit tests.\n * \\@docs-private\n * @type {?}\n */\nconst MAT_PROGRESS_BAR_LOCATION = new InjectionToken('mat-progress-bar-location', { providedIn: 'root', factory: MAT_PROGRESS_BAR_LOCATION_FACTORY });\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction MAT_PROGRESS_BAR_LOCATION_FACTORY() {\n    /** @type {?} */\n    const _document = inject(DOCUMENT);\n    /** @type {?} */\n    const _location = _document ? _document.location : null;\n    return {\n        // Note that this needs to be a function, rather than a property, because Angular\n        // will only resolve it once, but we want the current path on each call.\n        getPathname: (/**\n         * @return {?}\n         */\n        () => _location ? (_location.pathname + _location.search) : '')\n    };\n}\n/**\n * Counter used to generate unique IDs for progress bars.\n * @type {?}\n */\nlet progressbarId = 0;\n/**\n * `<mat-progress-bar>` component.\n */\nclass MatProgressBar extends _MatProgressBarMixinBase {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _ngZone\n     * @param {?=} _animationMode\n     * @param {?=} location\n     */\n    constructor(_elementRef, _ngZone, _animationMode, \n    /**\n     * @deprecated `location` parameter to be made required.\n     * @breaking-change 8.0.0\n     */\n    location) {\n        super(_elementRef);\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        this._animationMode = _animationMode;\n        /**\n         * Flag that indicates whether NoopAnimations mode is set to true.\n         */\n        this._isNoopAnimation = false;\n        this._value = 0;\n        this._bufferValue = 0;\n        /**\n         * Event emitted when animation of the primary progress bar completes. This event will not\n         * be emitted when animations are disabled, nor will it be emitted for modes with continuous\n         * animations (indeterminate and query).\n         */\n        this.animationEnd = new EventEmitter();\n        /**\n         * Reference to animation end subscription to be unsubscribed on destroy.\n         */\n        this._animationEndSubscription = Subscription.EMPTY;\n        /**\n         * Mode of the progress bar.\n         *\n         * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to\n         * 'determinate'.\n         * Mirrored to mode attribute.\n         */\n        this.mode = 'determinate';\n        /**\n         * ID of the progress bar.\n         */\n        this.progressbarId = `mat-progress-bar-${progressbarId++}`;\n        // We need to prefix the SVG reference with the current path, otherwise they won't work\n        // in Safari if the page has a `<base>` tag. Note that we need quotes inside the `url()`,\n        // because named route URLs can contain parentheses (see #12338). Also we don't use since\n        // we can't tell the difference between whether\n        // the consumer is using the hash location strategy or not, because `Location` normalizes\n        // both `/#/foo/bar` and `/foo/bar` to the same thing.\n        /** @type {?} */\n        const path = location ? location.getPathname().split('#')[0] : '';\n        this._rectangleFillValue = `url('${path}#${this.progressbarId}')`;\n        this._isNoopAnimation = _animationMode === 'NoopAnimations';\n    }\n    /**\n     * Value of the progress bar. Defaults to zero. Mirrored to aria-valuenow.\n     * @return {?}\n     */\n    get value() { return this._value; }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set value(v) {\n        this._value = clamp(v || 0);\n        // When noop animation is set to true, trigger animationEnd directly.\n        if (this._isNoopAnimation) {\n            this._emitAnimationEnd();\n        }\n    }\n    /**\n     * Buffer value of the progress bar. Defaults to zero.\n     * @return {?}\n     */\n    get bufferValue() { return this._bufferValue; }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    set bufferValue(v) { this._bufferValue = clamp(v || 0); }\n    /**\n     * Gets the current transform value for the progress bar's primary indicator.\n     * @return {?}\n     */\n    _primaryTransform() {\n        /** @type {?} */\n        const scale = this.value / 100;\n        return { transform: `scaleX(${scale})` };\n    }\n    /**\n     * Gets the current transform value for the progress bar's buffer indicator. Only used if the\n     * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.\n     * @return {?}\n     */\n    _bufferTransform() {\n        if (this.mode === 'buffer') {\n            /** @type {?} */\n            const scale = this.bufferValue / 100;\n            return { transform: `scaleX(${scale})` };\n        }\n        return undefined;\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        if (!this._isNoopAnimation) {\n            // Run outside angular so change detection didn't get triggered on every transition end\n            // instead only on the animation that we care about (primary value bar's transitionend)\n            this._ngZone.runOutsideAngular(((/**\n             * @return {?}\n             */\n            () => {\n                /** @type {?} */\n                const element = this._primaryValueBar.nativeElement;\n                this._animationEndSubscription =\n                    ((/** @type {?} */ (fromEvent(element, 'transitionend'))))\n                        .pipe(filter(((/**\n                     * @param {?} e\n                     * @return {?}\n                     */\n                    (e) => e.target === element))))\n                        .subscribe((/**\n                     * @return {?}\n                     */\n                    () => this._ngZone.run((/**\n                     * @return {?}\n                     */\n                    () => this._emitAnimationEnd()))));\n            })));\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._animationEndSubscription.unsubscribe();\n    }\n    /**\n     * Emit an animationEnd event if in determinate or buffer mode.\n     * @private\n     * @return {?}\n     */\n    _emitAnimationEnd() {\n        if (this.mode === 'determinate' || this.mode === 'buffer') {\n            this.animationEnd.next({ value: this.value });\n        }\n    }\n}\nMatProgressBar.decorators = [\n    { type: Component, args: [{selector: 'mat-progress-bar',\n                exportAs: 'matProgressBar',\n                host: {\n                    'role': 'progressbar',\n                    'aria-valuemin': '0',\n                    'aria-valuemax': '100',\n                    '[attr.aria-valuenow]': '(mode === \"indeterminate\" || mode === \"query\") ? null : value',\n                    '[attr.mode]': 'mode',\n                    'class': 'mat-progress-bar',\n                    '[class._mat-animation-noopable]': '_isNoopAnimation',\n                },\n                inputs: ['color'],\n                template: \"<svg width=\\\"100%\\\" height=\\\"4\\\" focusable=\\\"false\\\" class=\\\"mat-progress-bar-background mat-progress-bar-element\\\"><defs><pattern [id]=\\\"progressbarId\\\" x=\\\"4\\\" y=\\\"0\\\" width=\\\"8\\\" height=\\\"4\\\" patternUnits=\\\"userSpaceOnUse\\\"><circle cx=\\\"2\\\" cy=\\\"2\\\" r=\\\"2\\\"/></pattern></defs><rect [attr.fill]=\\\"_rectangleFillValue\\\" width=\\\"100%\\\" height=\\\"100%\\\"/></svg><div class=\\\"mat-progress-bar-buffer mat-progress-bar-element\\\" [ngStyle]=\\\"_bufferTransform()\\\"></div><div class=\\\"mat-progress-bar-primary mat-progress-bar-fill mat-progress-bar-element\\\" [ngStyle]=\\\"_primaryTransform()\\\" #primaryValueBar></div><div class=\\\"mat-progress-bar-secondary mat-progress-bar-fill mat-progress-bar-element\\\"></div>\",\n                styles: [\".mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-background{display:none}}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:'';display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2s infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2s infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2s infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2s infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after{animation:none;transition:none}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(.5,0,.70173,.49582);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635);transform:translateX(83.67142%)}100%{transform:translateX(200.61106%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.33473,.12482,.78584,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.66148)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:translateX(37.65191%)}48.35%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:translateX(84.38617%)}100%{transform:translateX(160.27778%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:scaleX(.4571)}44.15%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:scaleX(.72796)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}\"],\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n            },] },\n];\n/** @nocollapse */\nMatProgressBar.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone },\n    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_PROGRESS_BAR_LOCATION,] }] }\n];\nMatProgressBar.propDecorators = {\n    value: [{ type: Input }],\n    bufferValue: [{ type: Input }],\n    _primaryValueBar: [{ type: ViewChild, args: ['primaryValueBar', { static: false },] }],\n    animationEnd: [{ type: Output }],\n    mode: [{ type: Input }]\n};\n/**\n * Clamps a value to be between two numbers, by default 0 and 100.\n * @param {?} v\n * @param {?=} min\n * @param {?=} max\n * @return {?}\n */\nfunction clamp(v, min = 0, max = 100) {\n    return Math.max(min, Math.min(max, v));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatProgressBarModule {\n}\nMatProgressBarModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [CommonModule, MatCommonModule],\n                exports: [MatProgressBar, MatCommonModule],\n                declarations: [MatProgressBar],\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { MatProgressBarModule, MAT_PROGRESS_BAR_LOCATION_FACTORY, MAT_PROGRESS_BAR_LOCATION, MatProgressBar };\n//# sourceMappingURL=progress-bar.js.map\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/material/progress-bar\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"@angular/cdk/bidi\";\nimport * as i4 from \"@angular/material/core\";\nimport * as i5 from \"@angular/platform-browser\";\nimport * as i6 from \"@angular/platform-browser/animations\";\nvar MatProgressBarModuleNgFactory = i0.ɵcmf(i1.MatProgressBarModule, [], function (_l) { return i0.ɵmod([i0.ɵmpd(512, i0.ComponentFactoryResolver, i0.ɵCodegenComponentFactoryResolver, [[8, []], [3, i0.ComponentFactoryResolver], i0.NgModuleRef]), i0.ɵmpd(4608, i2.NgLocalization, i2.NgLocaleLocalization, [i0.LOCALE_ID, [2, i2.ɵangular_packages_common_common_a]]), i0.ɵmpd(1073742336, i2.CommonModule, i2.CommonModule, []), i0.ɵmpd(1073742336, i3.BidiModule, i3.BidiModule, []), i0.ɵmpd(1073742336, i4.MatCommonModule, i4.MatCommonModule, [[2, i4.MATERIAL_SANITY_CHECKS], [2, i5.HAMMER_LOADER]]), i0.ɵmpd(1073742336, i1.MatProgressBarModule, i1.MatProgressBarModule, [])]); });\nexport { MatProgressBarModuleNgFactory as MatProgressBarModuleNgFactory };\nvar styles_MatProgressBar = [\".mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-background{display:none}}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:'';display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2s infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2s infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2s infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2s infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after{animation:none;transition:none}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(.5,0,.70173,.49582);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635);transform:translateX(83.67142%)}100%{transform:translateX(200.61106%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.33473,.12482,.78584,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.66148)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:translateX(37.65191%)}48.35%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:translateX(84.38617%)}100%{transform:translateX(160.27778%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:scaleX(.4571)}44.15%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:scaleX(.72796)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}\"];\nvar RenderType_MatProgressBar = i0.ɵcrt({ encapsulation: 2, styles: styles_MatProgressBar, data: {} });\nexport { RenderType_MatProgressBar as RenderType_MatProgressBar };\nexport function View_MatProgressBar_0(_l) { return i0.ɵvid(2, [i0.ɵqud(671088640, 1, { _primaryValueBar: 0 }), (_l()(), i0.ɵeld(1, 0, null, null, 4, \":svg:svg\", [[\"class\", \"mat-progress-bar-background mat-progress-bar-element\"], [\"focusable\", \"false\"], [\"height\", \"4\"], [\"width\", \"100%\"]], null, null, null, null, null)), (_l()(), i0.ɵeld(2, 0, null, null, 2, \":svg:defs\", [], null, null, null, null, null)), (_l()(), i0.ɵeld(3, 0, null, null, 1, \":svg:pattern\", [[\"height\", \"4\"], [\"patternUnits\", \"userSpaceOnUse\"], [\"width\", \"8\"], [\"x\", \"4\"], [\"y\", \"0\"]], [[8, \"id\", 0]], null, null, null, null)), (_l()(), i0.ɵeld(4, 0, null, null, 0, \":svg:circle\", [[\"cx\", \"2\"], [\"cy\", \"2\"], [\"r\", \"2\"]], null, null, null, null, null)), (_l()(), i0.ɵeld(5, 0, null, null, 0, \":svg:rect\", [[\"height\", \"100%\"], [\"width\", \"100%\"]], [[1, \"fill\", 0]], null, null, null, null)), (_l()(), i0.ɵeld(6, 0, null, null, 2, \"div\", [[\"class\", \"mat-progress-bar-buffer mat-progress-bar-element\"]], null, null, null, null, null)), i0.ɵprd(512, null, i2.ɵNgStyleImpl, i2.ɵNgStyleR2Impl, [i0.ElementRef, i0.KeyValueDiffers, i0.Renderer2]), i0.ɵdid(8, 278528, null, 0, i2.NgStyle, [i2.ɵNgStyleImpl], { ngStyle: [0, \"ngStyle\"] }, null), (_l()(), i0.ɵeld(9, 0, [[1, 0], [\"primaryValueBar\", 1]], null, 2, \"div\", [[\"class\", \"mat-progress-bar-primary mat-progress-bar-fill mat-progress-bar-element\"]], null, null, null, null, null)), i0.ɵprd(512, null, i2.ɵNgStyleImpl, i2.ɵNgStyleR2Impl, [i0.ElementRef, i0.KeyValueDiffers, i0.Renderer2]), i0.ɵdid(11, 278528, null, 0, i2.NgStyle, [i2.ɵNgStyleImpl], { ngStyle: [0, \"ngStyle\"] }, null), (_l()(), i0.ɵeld(12, 0, null, null, 0, \"div\", [[\"class\", \"mat-progress-bar-secondary mat-progress-bar-fill mat-progress-bar-element\"]], null, null, null, null, null))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _co._bufferTransform(); _ck(_v, 8, 0, currVal_2); var currVal_3 = _co._primaryTransform(); _ck(_v, 11, 0, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.progressbarId; _ck(_v, 3, 0, currVal_0); var currVal_1 = _co._rectangleFillValue; _ck(_v, 5, 0, currVal_1); }); }\nexport function View_MatProgressBar_Host_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"mat-progress-bar\", [[\"aria-valuemax\", \"100\"], [\"aria-valuemin\", \"0\"], [\"class\", \"mat-progress-bar\"], [\"role\", \"progressbar\"]], [[1, \"aria-valuenow\", 0], [1, \"mode\", 0], [2, \"_mat-animation-noopable\", null]], null, null, View_MatProgressBar_0, RenderType_MatProgressBar)), i0.ɵdid(1, 4374528, null, 0, i1.MatProgressBar, [i0.ElementRef, i0.NgZone, [2, i6.ANIMATION_MODULE_TYPE], [2, i1.MAT_PROGRESS_BAR_LOCATION]], null, null)], null, function (_ck, _v) { var currVal_0 = (((i0.ɵnov(_v, 1).mode === \"indeterminate\") || (i0.ɵnov(_v, 1).mode === \"query\")) ? null : i0.ɵnov(_v, 1).value); var currVal_1 = i0.ɵnov(_v, 1).mode; var currVal_2 = i0.ɵnov(_v, 1)._isNoopAnimation; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2); }); }\nvar MatProgressBarNgFactory = i0.ɵccf(\"mat-progress-bar\", i1.MatProgressBar, View_MatProgressBar_Host_0, { color: \"color\", value: \"value\", bufferValue: \"bufferValue\", mode: \"mode\" }, { animationEnd: \"animationEnd\" }, []);\nexport { MatProgressBarNgFactory as MatProgressBarNgFactory };\n","<svg width=\"100%\" height=\"4\" focusable=\"false\" class=\"mat-progress-bar-background mat-progress-bar-element\"><defs><pattern [id]=\"progressbarId\" x=\"4\" y=\"0\" width=\"8\" height=\"4\" patternUnits=\"userSpaceOnUse\"><circle cx=\"2\" cy=\"2\" r=\"2\"/></pattern></defs><rect [attr.fill]=\"_rectangleFillValue\" width=\"100%\" height=\"100%\"/></svg><div class=\"mat-progress-bar-buffer mat-progress-bar-element\" [ngStyle]=\"_bufferTransform()\"></div><div class=\"mat-progress-bar-primary mat-progress-bar-fill mat-progress-bar-element\" [ngStyle]=\"_primaryTransform()\" #primaryValueBar></div><div class=\"mat-progress-bar-secondary mat-progress-bar-fill mat-progress-bar-element\"></div>","import { Subscriber } from '../Subscriber';\nimport { async } from '../scheduler/async';\nexport function sampleTime(period, scheduler = async) {\n    return (source) => source.lift(new SampleTimeOperator(period, scheduler));\n}\nclass SampleTimeOperator {\n    constructor(period, scheduler) {\n        this.period = period;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n    }\n}\nclass SampleTimeSubscriber extends Subscriber {\n    constructor(destination, period, scheduler) {\n        super(destination);\n        this.period = period;\n        this.scheduler = scheduler;\n        this.hasValue = false;\n        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period }));\n    }\n    _next(value) {\n        this.lastValue = value;\n        this.hasValue = true;\n    }\n    notifyNext() {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.lastValue);\n        }\n    }\n}\nfunction dispatchNotification(state) {\n    let { subscriber, period } = state;\n    subscriber.notifyNext();\n    this.schedule(state, period);\n}\n//# sourceMappingURL=sampleTime.js.map","import { Directive, ElementRef, EventEmitter, Input, NgModule, NgZone, Output } from '@angular/core';\nimport { fromEvent, of } from 'rxjs';\nimport { filter, map, mergeMap, sampleTime, tap } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} selector\n * @param {?} scrollWindow\n * @param {?} defaultElement\n * @param {?} fromRoot\n * @return {?}\n */\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n    /** @type {?} */\n    const hasWindow = window && !!window.document && window.document.documentElement;\n    /** @type {?} */\n    let container = hasWindow && scrollWindow ? window : defaultElement;\n    if (selector) {\n        /** @type {?} */\n        const containerIsString = selector && hasWindow && typeof selector === 'string';\n        container = containerIsString\n            ? findElement(selector, defaultElement.nativeElement, fromRoot)\n            : selector;\n        if (!container) {\n            throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n        }\n    }\n    return container;\n}\n/**\n * @param {?} selector\n * @param {?} customRoot\n * @param {?} fromRoot\n * @return {?}\n */\nfunction findElement(selector, customRoot, fromRoot) {\n    /** @type {?} */\n    const rootEl = fromRoot ? window.document : customRoot;\n    return rootEl.querySelector(selector);\n}\n/**\n * @param {?} prop\n * @return {?}\n */\nfunction inputPropChanged(prop) {\n    return prop && !prop.firstChange;\n}\n/**\n * @return {?}\n */\nfunction hasWindowDefined() {\n    return typeof window !== 'undefined';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst VerticalProps = {\n    clientHeight: \"clientHeight\",\n    offsetHeight: \"offsetHeight\",\n    scrollHeight: \"scrollHeight\",\n    pageYOffset: \"pageYOffset\",\n    offsetTop: \"offsetTop\",\n    scrollTop: \"scrollTop\",\n    top: \"top\"\n};\n/** @type {?} */\nconst HorizontalProps = {\n    clientHeight: \"clientWidth\",\n    offsetHeight: \"offsetWidth\",\n    scrollHeight: \"scrollWidth\",\n    pageYOffset: \"pageXOffset\",\n    offsetTop: \"offsetLeft\",\n    scrollTop: \"scrollLeft\",\n    top: \"left\"\n};\nclass AxisResolver {\n    /**\n     * @param {?=} vertical\n     */\n    constructor(vertical = true) {\n        this.vertical = vertical;\n        this.propsMap = vertical ? VerticalProps : HorizontalProps;\n    }\n    /**\n     * @return {?}\n     */\n    clientHeightKey() {\n        return this.propsMap.clientHeight;\n    }\n    /**\n     * @return {?}\n     */\n    offsetHeightKey() {\n        return this.propsMap.offsetHeight;\n    }\n    /**\n     * @return {?}\n     */\n    scrollHeightKey() {\n        return this.propsMap.scrollHeight;\n    }\n    /**\n     * @return {?}\n     */\n    pageYOffsetKey() {\n        return this.propsMap.pageYOffset;\n    }\n    /**\n     * @return {?}\n     */\n    offsetTopKey() {\n        return this.propsMap.offsetTop;\n    }\n    /**\n     * @return {?}\n     */\n    scrollTopKey() {\n        return this.propsMap.scrollTop;\n    }\n    /**\n     * @return {?}\n     */\n    topKey() {\n        return this.propsMap.top;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @record\n */\n\n/**\n * @param {?} alwaysCallback\n * @param {?} shouldFireScrollEvent\n * @param {?} isTriggeredCurrentTotal\n * @return {?}\n */\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n    if (alwaysCallback && shouldFireScrollEvent) {\n        return true;\n    }\n    if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction createResolver({ windowElement, axis }) {\n    return createResolverWithContainer({ axis, isWindow: isElementWindow(windowElement) }, windowElement);\n}\n/**\n * @param {?} resolver\n * @param {?} windowElement\n * @return {?}\n */\nfunction createResolverWithContainer(resolver, windowElement) {\n    /** @type {?} */\n    const container = resolver.isWindow || (windowElement && !windowElement.nativeElement)\n        ? windowElement\n        : windowElement.nativeElement;\n    return Object.assign({}, resolver, { container });\n}\n/**\n * @param {?} windowElement\n * @return {?}\n */\nfunction isElementWindow(windowElement) {\n    /** @type {?} */\n    const isWindow = ['Window', 'global'].some((obj) => Object.prototype.toString.call(windowElement).includes(obj));\n    return isWindow;\n}\n/**\n * @param {?} isContainerWindow\n * @param {?} windowElement\n * @return {?}\n */\nfunction getDocumentElement(isContainerWindow, windowElement) {\n    return isContainerWindow ? windowElement.document.documentElement : null;\n}\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePoints(element, resolver) {\n    /** @type {?} */\n    const height = extractHeightForElement(resolver);\n    return resolver.isWindow\n        ? calculatePointsForWindow(height, element, resolver)\n        : calculatePointsForElement(height, element, resolver);\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePointsForWindow(height, element, resolver) {\n    const { axis, container, isWindow } = resolver;\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    // scrolled until now / current y point\n    /** @type {?} */\n    const scrolled = height +\n        getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);\n    // total height / most bottom y point\n    /** @type {?} */\n    const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n    /** @type {?} */\n    const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) +\n        nativeElementHeight;\n    return { height, scrolled, totalToScroll, isWindow };\n}\n/**\n * @param {?} height\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\nfunction calculatePointsForElement(height, element, resolver) {\n    const { axis, container } = resolver;\n    // perhaps use container.offsetTop instead of 'scrollTop'\n    /** @type {?} */\n    const scrolled = container[axis.scrollTopKey()];\n    /** @type {?} */\n    const totalToScroll = container[axis.scrollHeightKey()];\n    return { height, scrolled, totalToScroll, isWindow: false };\n}\n/**\n * @param {?} axis\n * @return {?}\n */\nfunction extractHeightPropKeys(axis) {\n    return {\n        offsetHeightKey: axis.offsetHeightKey(),\n        clientHeightKey: axis.clientHeightKey()\n    };\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction extractHeightForElement({ container, isWindow, axis }) {\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\n/**\n * @param {?} elem\n * @param {?} isWindow\n * @param {?} offsetHeightKey\n * @param {?} clientHeightKey\n * @return {?}\n */\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n    if (isNaN(elem[offsetHeightKey])) {\n        /** @type {?} */\n        const docElem = getDocumentElement(isWindow, elem);\n        return docElem ? docElem[clientHeightKey] : 0;\n    }\n    else {\n        return elem[offsetHeightKey];\n    }\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nfunction getElementOffsetTop(elem, axis, isWindow) {\n    /** @type {?} */\n    const topKey = axis.topKey();\n    // elem = elem.nativeElement;\n    if (!elem.getBoundingClientRect) {\n        // || elem.css('none')) {\n        return;\n    }\n    return (elem.getBoundingClientRect()[topKey] +\n        getElementPageYOffset(elem, axis, isWindow));\n}\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nfunction getElementPageYOffset(elem, axis, isWindow) {\n    /** @type {?} */\n    const pageYOffset = axis.pageYOffsetKey();\n    /** @type {?} */\n    const scrollTop = axis.scrollTopKey();\n    /** @type {?} */\n    const offsetTop = axis.offsetTopKey();\n    if (isNaN(window[pageYOffset])) {\n        return getDocumentElement(isWindow, elem)[scrollTop];\n    }\n    else if (elem.ownerDocument) {\n        return elem.ownerDocument.defaultView[pageYOffset];\n    }\n    else {\n        return elem[offsetTop];\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} container\n * @param {?} distance\n * @param {?} scrollingDown\n * @return {?}\n */\nfunction shouldFireScrollEvent(container, distance, scrollingDown) {\n    /** @type {?} */\n    let remaining;\n    /** @type {?} */\n    let containerBreakpoint;\n    if (container.totalToScroll <= 0) {\n        return false;\n    }\n    /** @type {?} */\n    const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n    if (scrollingDown) {\n        remaining =\n            (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n        containerBreakpoint = distance.down / 10;\n    }\n    else {\n        /** @type {?} */\n        const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n        remaining = container.scrolled / totalHiddenContentHeight;\n        containerBreakpoint = distance.up / 10;\n    }\n    /** @type {?} */\n    const shouldFireEvent = remaining <= containerBreakpoint;\n    return shouldFireEvent;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @return {?}\n */\nfunction isScrollingDownwards(lastScrollPosition, container) {\n    return lastScrollPosition < container.scrolled;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} container\n * @param {?} distance\n * @return {?}\n */\nfunction getScrollStats(lastScrollPosition, container, distance) {\n    /** @type {?} */\n    const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n    return {\n        fire: shouldFireScrollEvent(container, distance, scrollDown),\n        scrollDown\n    };\n}\n/**\n * @param {?} position\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @return {?}\n */\n\n/**\n * @param {?} scroll\n * @param {?} scrollState\n * @param {?} triggered\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} totalToScroll\n * @param {?} scrollState\n * @param {?} isScrollingDown\n * @return {?}\n */\n\n/**\n * @param {?} scrollState\n * @param {?} scrolledUntilNow\n * @param {?} totalToScroll\n * @return {?}\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass ScrollState {\n    /**\n     * @param {?} __0\n     */\n    constructor({ totalToScroll }) {\n        this.lastScrollPosition = 0;\n        this.lastTotalToScroll = 0;\n        this.totalToScroll = 0;\n        this.triggered = {\n            down: 0,\n            up: 0\n        };\n        this.totalToScroll = totalToScroll;\n    }\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    updateScrollPosition(position) {\n        return (this.lastScrollPosition = position);\n    }\n    /**\n     * @param {?} totalToScroll\n     * @return {?}\n     */\n    updateTotalToScroll(totalToScroll) {\n        if (this.lastTotalToScroll !== totalToScroll) {\n            this.lastTotalToScroll = this.totalToScroll;\n            this.totalToScroll = totalToScroll;\n        }\n    }\n    /**\n     * @param {?} scrolledUntilNow\n     * @param {?} totalToScroll\n     * @return {?}\n     */\n    updateScroll(scrolledUntilNow, totalToScroll) {\n        this.updateScrollPosition(scrolledUntilNow);\n        this.updateTotalToScroll(totalToScroll);\n    }\n    /**\n     * @param {?} scroll\n     * @param {?} isScrollingDown\n     * @return {?}\n     */\n    updateTriggeredFlag(scroll, isScrollingDown) {\n        if (isScrollingDown) {\n            this.triggered.down = scroll;\n        }\n        else {\n            this.triggered.up = scroll;\n        }\n    }\n    /**\n     * @param {?} totalToScroll\n     * @param {?} isScrollingDown\n     * @return {?}\n     */\n    isTriggeredScroll(totalToScroll, isScrollingDown) {\n        return isScrollingDown\n            ? this.triggered.down === totalToScroll\n            : this.triggered.up === totalToScroll;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} config\n * @return {?}\n */\nfunction createScroller(config) {\n    const { scrollContainer, scrollWindow, element, fromRoot } = config;\n    /** @type {?} */\n    const resolver = createResolver({\n        axis: new AxisResolver(!config.horizontal),\n        windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n    });\n    /** @type {?} */\n    const scrollState = new ScrollState({\n        totalToScroll: calculatePoints(element, resolver)\n    });\n    /** @type {?} */\n    const options = {\n        container: resolver.container,\n        throttle: config.throttle\n    };\n    /** @type {?} */\n    const distance = {\n        up: config.upDistance,\n        down: config.downDistance\n    };\n    return attachScrollEvent(options).pipe(mergeMap(() => of(calculatePoints(element, resolver))), map((positionStats) => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), tap(({ stats }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), filter(({ fire, scrollDown, stats: { totalToScroll } }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), tap(({ scrollDown, stats: { totalToScroll } }) => {\n        scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n    }), map(toInfiniteScrollAction));\n}\n/**\n * @param {?} options\n * @return {?}\n */\nfunction attachScrollEvent(options) {\n    /** @type {?} */\n    let obs = fromEvent(options.container, 'scroll');\n    // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n    // Let's avoid calling the function unless needed.\n    // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n    if (options.throttle) {\n        obs = obs.pipe(sampleTime(options.throttle));\n    }\n    return obs;\n}\n/**\n * @param {?} lastScrollPosition\n * @param {?} stats\n * @param {?} distance\n * @return {?}\n */\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n    const { scrollDown, fire } = getScrollStats(lastScrollPosition, stats, distance);\n    return {\n        scrollDown,\n        fire,\n        stats\n    };\n}\n/** @type {?} */\nconst InfiniteScrollActions = {\n    DOWN: '[NGX_ISE] DOWN',\n    UP: '[NGX_ISE] UP'\n};\n/**\n * @param {?} response\n * @return {?}\n */\nfunction toInfiniteScrollAction(response) {\n    const { scrollDown, stats: { scrolled: currentScrollPosition } } = response;\n    return {\n        type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n        payload: {\n            currentScrollPosition\n        }\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass InfiniteScrollDirective {\n    /**\n     * @param {?} element\n     * @param {?} zone\n     */\n    constructor(element, zone) {\n        this.element = element;\n        this.zone = zone;\n        this.scrolled = new EventEmitter();\n        this.scrolledUp = new EventEmitter();\n        this.infiniteScrollDistance = 2;\n        this.infiniteScrollUpDistance = 1.5;\n        this.infiniteScrollThrottle = 150;\n        this.infiniteScrollDisabled = false;\n        this.infiniteScrollContainer = null;\n        this.scrollWindow = true;\n        this.immediateCheck = false;\n        this.horizontal = false;\n        this.alwaysCallback = false;\n        this.fromRoot = false;\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        if (!this.infiniteScrollDisabled) {\n            this.setup();\n        }\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    ngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance }) {\n        /** @type {?} */\n        const containerChanged = inputPropChanged(infiniteScrollContainer);\n        /** @type {?} */\n        const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n        /** @type {?} */\n        const distanceChanged = inputPropChanged(infiniteScrollDistance);\n        /** @type {?} */\n        const shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||\n            (disabledChanged && !infiniteScrollDisabled.currentValue) || distanceChanged;\n        if (containerChanged || disabledChanged || distanceChanged) {\n            this.destroyScroller();\n            if (shouldSetup) {\n                this.setup();\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    setup() {\n        if (hasWindowDefined()) {\n            this.zone.runOutsideAngular(() => {\n                this.disposeScroller = createScroller({\n                    fromRoot: this.fromRoot,\n                    alwaysCallback: this.alwaysCallback,\n                    disable: this.infiniteScrollDisabled,\n                    downDistance: this.infiniteScrollDistance,\n                    element: this.element,\n                    horizontal: this.horizontal,\n                    scrollContainer: this.infiniteScrollContainer,\n                    scrollWindow: this.scrollWindow,\n                    throttle: this.infiniteScrollThrottle,\n                    upDistance: this.infiniteScrollUpDistance\n                }).subscribe((payload) => this.zone.run(() => this.handleOnScroll(payload)));\n            });\n        }\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    handleOnScroll({ type, payload }) {\n        switch (type) {\n            case InfiniteScrollActions.DOWN:\n                return this.scrolled.emit(payload);\n            case InfiniteScrollActions.UP:\n                return this.scrolledUp.emit(payload);\n            default:\n                return;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.destroyScroller();\n    }\n    /**\n     * @return {?}\n     */\n    destroyScroller() {\n        if (this.disposeScroller) {\n            this.disposeScroller.unsubscribe();\n        }\n    }\n}\nInfiniteScrollDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n            },] },\n];\n/** @nocollapse */\nInfiniteScrollDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: NgZone }\n];\nInfiniteScrollDirective.propDecorators = {\n    scrolled: [{ type: Output }],\n    scrolledUp: [{ type: Output }],\n    infiniteScrollDistance: [{ type: Input }],\n    infiniteScrollUpDistance: [{ type: Input }],\n    infiniteScrollThrottle: [{ type: Input }],\n    infiniteScrollDisabled: [{ type: Input }],\n    infiniteScrollContainer: [{ type: Input }],\n    scrollWindow: [{ type: Input }],\n    immediateCheck: [{ type: Input }],\n    horizontal: [{ type: Input }],\n    alwaysCallback: [{ type: Input }],\n    fromRoot: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass InfiniteScrollModule {\n}\nInfiniteScrollModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [InfiniteScrollDirective],\n                exports: [InfiniteScrollDirective],\n                imports: [],\n                providers: []\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Angular library starter.\n * Build an Angular library compatible with AoT compilation & Tree shaking.\n * Written by Roberto Simonetti.\n * MIT license.\n * https://github.com/robisim74/angular-library-starter\n */\n/**\n * Entry point for all public APIs of the package.\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InfiniteScrollDirective, InfiniteScrollModule };\n//# sourceMappingURL=ngx-infinite-scroll.js.map\n","import {\n    AfterContentInit,\n    ChangeDetectorRef,\n    Component,\n    ElementRef,\n    ViewChild\n} from \"@angular/core\";\n\n@Component({\n    selector: \"jellyfin-slider\",\n    templateUrl: \"./slider.component.html\",\n    styleUrls: [\"./slider.component.scss\"]\n})\nexport class SliderComponent implements AfterContentInit {\n    @ViewChild(\"slider\", { static: true }) public slider: ElementRef<HTMLDivElement>;\n\n    constructor(private changeDetector: ChangeDetectorRef) {}\n\n    public ngAfterContentInit() {\n        this.slider.nativeElement.addEventListener(\"scroll\", () => {\n            this.changeDetector.detectChanges();\n        });\n    }\n\n    public more() {\n        console.log(\"load more\");\n    }\n\n    public left() {\n        const parentRect = (this.slider.nativeElement.getClientRects() as DOMRectList)[0];\n        for (const child of Array.from(this.slider.nativeElement.children).reverse()) {\n            const rect = (child.getClientRects() as DOMRectList)[0];\n            const beyondBorder = rect.right < parentRect.left;\n            if (beyondBorder) {\n                child.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n                break;\n            }\n        }\n    }\n\n    public right() {\n        const parentRect = (this.slider.nativeElement.getClientRects() as DOMRectList)[0];\n        for (const child of Array.from(this.slider.nativeElement.children)) {\n            const rect = (child.getClientRects() as DOMRectList)[0];\n            const beyondBorder = rect.left > parentRect.right;\n            if (beyondBorder) {\n                child.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\n                break;\n            }\n        }\n    }\n\n    public get isLeft() {\n        const parentRect = (this.slider.nativeElement.getClientRects() as DOMRectList)[0];\n        const rect = (this.slider.nativeElement.children[1].getClientRects() as DOMRectList)[0];\n        return rect.left >= parentRect.left;\n    }\n\n    public get isRight() {\n        const parentRect = (this.slider.nativeElement.getClientRects() as DOMRectList)[0];\n        const rect = (this.slider.nativeElement.children[\n            this.slider.nativeElement.children.length - 2\n        ].getClientRects() as DOMRectList)[0];\n        return rect.right <= parentRect.right;\n    }\n}\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"./slider.component.scss.shim.ngstyle\";\nimport * as i1 from \"@angular/core\";\nimport * as i2 from \"../../../../node_modules/@angular/material/button/typings/index.ngfactory\";\nimport * as i3 from \"@angular/material/button\";\nimport * as i4 from \"@angular/cdk/a11y\";\nimport * as i5 from \"@angular/platform-browser/animations\";\nimport * as i6 from \"ngx-infinite-scroll\";\nimport * as i7 from \"./slider.component\";\nvar styles_SliderComponent = [i0.styles];\nvar RenderType_SliderComponent = i1.ɵcrt({ encapsulation: 0, styles: styles_SliderComponent, data: {} });\nexport { RenderType_SliderComponent as RenderType_SliderComponent };\nexport function View_SliderComponent_0(_l) { return i1.ɵvid(0, [i1.ɵqud(402653184, 1, { slider: 0 }), (_l()(), i1.ɵeld(1, 0, null, null, 11, \"div\", [[\"class\", \"wrapper\"]], null, null, null, null, null)), (_l()(), i1.ɵeld(2, 0, null, null, 2, \"button\", [[\"class\", \"scroll-fab left\"], [\"mat-fab\", \"\"]], [[1, \"disabled\", 0], [2, \"_mat-animation-noopable\", null]], [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.left() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, i2.View_MatButton_0, i2.RenderType_MatButton)), i1.ɵdid(3, 180224, null, 0, i3.MatButton, [i1.ElementRef, i4.FocusMonitor, [2, i5.ANIMATION_MODULE_TYPE]], { disabled: [0, \"disabled\"] }, null), (_l()(), i1.ɵted(-1, 0, [\"<\"])), (_l()(), i1.ɵeld(5, 0, null, null, 2, \"button\", [[\"class\", \"scroll-fab right\"], [\"mat-fab\", \"\"]], [[1, \"disabled\", 0], [2, \"_mat-animation-noopable\", null]], [[null, \"click\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.right() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, i2.View_MatButton_0, i2.RenderType_MatButton)), i1.ɵdid(6, 180224, null, 0, i3.MatButton, [i1.ElementRef, i4.FocusMonitor, [2, i5.ANIMATION_MODULE_TYPE]], { disabled: [0, \"disabled\"] }, null), (_l()(), i1.ɵted(-1, 0, [\">\"])), (_l()(), i1.ɵeld(8, 0, [[1, 0], [\"slider\", 1]], null, 4, \"div\", [[\"class\", \"slider\"], [\"horizontal\", \"\"], [\"infinite-scroll\", \"\"]], null, [[null, \"scrolled\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"scrolled\" === en)) {\n        var pd_0 = (_co.more() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i1.ɵdid(9, 4866048, null, 0, i6.InfiniteScrollDirective, [i1.ElementRef, i1.NgZone], { horizontal: [0, \"horizontal\"] }, { scrolled: \"scrolled\" }), (_l()(), i1.ɵeld(10, 0, null, null, 0, \"div\", [[\"class\", \"start\"]], null, null, null, null, null)), i1.ɵncd(null, 0), (_l()(), i1.ɵeld(12, 0, null, null, 0, \"div\", [[\"class\", \"end\"]], null, null, null, null, null))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _co.isLeft; _ck(_v, 3, 0, currVal_2); var currVal_5 = _co.isRight; _ck(_v, 6, 0, currVal_5); var currVal_6 = \"\"; _ck(_v, 9, 0, currVal_6); }, function (_ck, _v) { var currVal_0 = (i1.ɵnov(_v, 3).disabled || null); var currVal_1 = (i1.ɵnov(_v, 3)._animationMode === \"NoopAnimations\"); _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_3 = (i1.ɵnov(_v, 6).disabled || null); var currVal_4 = (i1.ɵnov(_v, 6)._animationMode === \"NoopAnimations\"); _ck(_v, 5, 0, currVal_3, currVal_4); }); }\nexport function View_SliderComponent_Host_0(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 1, \"jellyfin-slider\", [], null, null, null, View_SliderComponent_0, RenderType_SliderComponent)), i1.ɵdid(1, 1097728, null, 0, i7.SliderComponent, [i1.ChangeDetectorRef], null, null)], null, null); }\nvar SliderComponentNgFactory = i1.ɵccf(\"jellyfin-slider\", i7.SliderComponent, View_SliderComponent_Host_0, {}, {}, [\"*\"]);\nexport { SliderComponentNgFactory as SliderComponentNgFactory };\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nvar styles = [\".wrapper[_ngcontent-%COMP%]{position:relative}.slider[_ngcontent-%COMP%]{padding:1rem;display:flex;flex-direction:row;overflow-x:auto;scroll-snap-type:x mandatory}.slider[_ngcontent-%COMP%] >   *{scroll-snap-align:start}.slider[_ngcontent-%COMP%]   .start[_ngcontent-%COMP%]{min-width:1px}.slider[_ngcontent-%COMP%]   .end[_ngcontent-%COMP%]{min-width:1px;scroll-snap-align:end}.scroll-fab[_ngcontent-%COMP%]{position:absolute;top:0;bottom:0;z-index:2;margin:auto;opacity:0;transition:opacity ease-in-out .25s}.scroll-fab.left[_ngcontent-%COMP%]{left:10px}.scroll-fab.right[_ngcontent-%COMP%]{right:10px}.wrapper[_ngcontent-%COMP%]:hover   .scroll-fab[_ngcontent-%COMP%]{opacity:1}.wrapper[_ngcontent-%COMP%]:hover   .scroll-fab[disabled][_ngcontent-%COMP%]{opacity:0;pointer-events:none}\"];\nexport { styles as styles };\n","<div class=\"wrapper\">\n    <button mat-fab class=\"scroll-fab left\" [disabled]=\"isLeft\" (click)=\"left()\">&lt;</button>\n    <button mat-fab class=\"scroll-fab right\" [disabled]=\"isRight\" (click)=\"right()\">&gt;</button>\n    <div class=\"slider\" #slider infinite-scroll horizontal (scrolled)=\"more()\">\n        <div class=\"start\"></div>\n        <ng-content></ng-content>\n        <div class=\"end\"></div>\n    </div>\n</div>\n","export function sleep(ms: number) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport function assertNever(value: never): never {\n    throw new Error(`Unexpected value \"${value}\"`);\n}\n","import { Component, OnInit } from \"@angular/core\";\nimport { Router, UrlTree } from \"@angular/router\";\nimport { map } from \"rxjs/operators\";\nimport { AuthService } from \"../../auth/auth.service\";\nimport { ApiService } from \"../../common/api/api.service\";\nimport { assertNever } from \"../../utils\";\n\nexport interface Tile {\n    image?: string;\n    subtitle: string;\n}\n\nexport const enum ViewTypes {\n    MOVIES = \"movies\",\n    HOME_VIDEOS = \"homevideos\"\n}\n\nexport interface ViewTile extends Tile {\n    type: ViewTypes;\n}\n\nexport interface MovieTile extends Tile {\n    year?: string | number;\n    originalTitle: string | null;\n}\n\nexport interface ContinueTile extends MovieTile {\n    progress: number;\n}\n\n@Component({\n    selector: \"jellyfin-home\",\n    templateUrl: \"./home.component.html\",\n    styleUrls: [\"./home.component.scss\"]\n})\nexport class HomeComponent implements OnInit {\n    // All images are just random tmdb images, inserted as design stubs\n    public myMedia: ViewTile[] = [];\n    public continueWatching: ContinueTile[] = [];\n    public latestMovies: MovieTile[] = [];\n    public loaded = false;\n\n    constructor(\n        private apiService: ApiService,\n        private authService: AuthService,\n        private router: Router\n    ) {}\n\n    public ngOnInit() {\n        Promise.all([this.loadViews(), this.loadStarted(), this.loadLatest()]).then(() => {\n            this.loaded = true;\n        });\n    }\n\n    public viewUrl(type: ViewTypes): UrlTree {\n        switch (type) {\n            case ViewTypes.MOVIES: {\n                return this.router.createUrlTree([\"movies\"]);\n            }\n            case ViewTypes.HOME_VIDEOS: {\n                return this.router.createUrlTree([\"home_videos\"]);\n            }\n            default: {\n                assertNever(type);\n            }\n        }\n    }\n\n    public viewIcon(type: ViewTypes): string {\n        switch (type) {\n            case ViewTypes.MOVIES: {\n                return \"movie\";\n            }\n            case ViewTypes.HOME_VIDEOS: {\n                return \"camera_alt\";\n            }\n            default: {\n                assertNever(type);\n            }\n        }\n    }\n\n    private loadViews() {\n        return this.apiService\n            .get<any>(`/emby/Users/${this.authService.userId}/Views`)\n            .pipe(\n                map(resp => {\n                    for (const item of resp.Items) {\n                        const tile: ViewTile = {\n                            subtitle: item.Name,\n                            type: item.CollectionType\n                        };\n                        if (item.ImageTags.Primary) {\n                            tile.image = this.apiService.assembleUrl(\n                                `/emby/Items/${item.Id}/Images/Primary`,\n                                {\n                                    tag: item.ImageTags.Primary,\n                                    quality: \"90\",\n                                    maxWidth: \"400\",\n                                    maxHeight: \"400\"\n                                }\n                            );\n                        }\n                        this.myMedia.push(tile);\n                    }\n                })\n            )\n            .toPromise();\n    }\n\n    private loadStarted() {\n        return this.apiService\n            .get<any>(`/emby/Users/${this.authService.userId}/Items/Resume`, {\n                token: this.authService.token,\n                query: {\n                    Limit: \"12\",\n                    Recursive: \"true\",\n                    ImageTypeLimit: \"1\",\n                    EnableImageTypes: \"Primary,Backdrop,Thumb\",\n                    EnableTotalRecordCount: \"false\",\n                    MediaTypes: \"Video\"\n                }\n            })\n            .pipe(\n                map(resp => {\n                    for (const item of resp.Items) {\n                        const [title, cut] = this.sliceTitle(item.Name);\n                        const tile: ContinueTile = {\n                            subtitle: title,\n                            year: new Date(item.PremiereDate).getFullYear(),\n                            originalTitle: cut ? item.Name : null,\n                            progress: item.UserData.PlayedPercentage\n                        };\n                        if (item.BackdropImageTags && item.BackdropImageTags.length > 0) {\n                            tile.image = this.apiService.assembleUrl(\n                                `/emby/Items/${item.Id}/Images/Backdrop`,\n                                {\n                                    tag: item.BackdropImageTags[0],\n                                    quality: \"90\",\n                                    maxWidth: \"400\",\n                                    maxHeight: \"400\"\n                                }\n                            );\n                        } else if (item.ImageTags && Object.keys(item.ImageTags).length > 0) {\n                            const imageType = Object.keys(item.ImageTags)[0];\n                            tile.image = this.apiService.assembleUrl(\n                                `/emby/Items/${item.Id}/Images/${imageType}`,\n                                {\n                                    tag: item.ImageTags[imageType],\n                                    quality: \"90\",\n                                    maxWidth: \"400\",\n                                    maxHeight: \"400\"\n                                }\n                            );\n                        }\n                        this.continueWatching.push(tile);\n                    }\n                })\n            )\n            .toPromise();\n    }\n\n    private loadLatest() {\n        return this.apiService\n            .get<any>(`/emby/Users/${this.authService.userId}/Items/Latest`, {\n                token: this.authService.token,\n                query: {\n                    Limit: \"10\",\n                    EnableImageType: \"Primary\"\n                }\n            })\n            .pipe(\n                map(resp => {\n                    for (const item of resp) {\n                        const [title, cut] = this.sliceTitle(item.Name);\n                        const tile: MovieTile = {\n                            subtitle: title,\n                            year: new Date(item.PemiereDate).getFullYear(),\n                            originalTitle: cut ? item.Name : null\n                        };\n                        if (item.ImageTags.Primary) {\n                            tile.image = this.apiService.assembleUrl(\n                                `/emby/Items/${item.Id}/Images/Primary`,\n                                {\n                                    tag: item.ImageTags.Primary,\n                                    quality: \"90\",\n                                    maxWidth: \"400\",\n                                    maxHeight: \"400\"\n                                }\n                            );\n                        }\n                        this.latestMovies.push(tile);\n                    }\n                })\n            )\n            .toPromise();\n    }\n\n    private sliceTitle(title) {\n        let cut = false;\n        if (title.length > 25) {\n            cut = true;\n            const space = title.slice(0, 26).lastIndexOf(\" \");\n            if (space > 15) {\n                title = `${title.slice(0, space)}...`;\n            } else {\n                title = `${title.slice(0, 26)}...`;\n            }\n        }\n        return [title, cut];\n    }\n}\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"./home.component.scss.shim.ngstyle\";\nimport * as i1 from \"@angular/core\";\nimport * as i2 from \"../../../../node_modules/@angular/material/icon/typings/index.ngfactory\";\nimport * as i3 from \"@angular/material/icon\";\nimport * as i4 from \"@angular/router\";\nimport * as i5 from \"@angular/common\";\nimport * as i6 from \"../../../../node_modules/@angular/material/card/typings/index.ngfactory\";\nimport * as i7 from \"@angular/material/card\";\nimport * as i8 from \"@angular/platform-browser/animations\";\nimport * as i9 from \"@angular/material/core\";\nimport * as i10 from \"@angular/cdk/platform\";\nimport * as i11 from \"@angular/material/tooltip\";\nimport * as i12 from \"@angular/cdk/overlay\";\nimport * as i13 from \"@angular/cdk/scrolling\";\nimport * as i14 from \"@angular/cdk/a11y\";\nimport * as i15 from \"@angular/cdk/bidi\";\nimport * as i16 from \"@angular/platform-browser\";\nimport * as i17 from \"../../../../node_modules/@angular/material/progress-bar/typings/index.ngfactory\";\nimport * as i18 from \"@angular/material/progress-bar\";\nimport * as i19 from \"../../common/slider/slider.component.ngfactory\";\nimport * as i20 from \"../../common/slider/slider.component\";\nimport * as i21 from \"../../../../node_modules/@angular/material/progress-spinner/typings/index.ngfactory\";\nimport * as i22 from \"@angular/material/progress-spinner\";\nimport * as i23 from \"./home.component\";\nimport * as i24 from \"../../common/api/api.service\";\nimport * as i25 from \"../../auth/auth.service\";\nvar styles_HomeComponent = [i0.styles];\nvar RenderType_HomeComponent = i1.ɵcrt({ encapsulation: 0, styles: styles_HomeComponent, data: {} });\nexport { RenderType_HomeComponent as RenderType_HomeComponent };\nfunction View_HomeComponent_3(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 1, \"div\", [[\"class\", \"img-wrapper\"]], null, null, null, null, null)), (_l()(), i1.ɵeld(1, 0, null, null, 0, \"img\", [[\"class\", \"inner-img\"]], [[8, \"src\", 4], [8, \"alt\", 0]], [[null, \"dragstart\"]], function (_v, en, $event) { var ad = true; if ((\"dragstart\" === en)) {\n        var pd_0 = ($event.preventDefault() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.$implicit.image; var currVal_1 = _v.parent.context.$implicit.subtitle; _ck(_v, 1, 0, currVal_0, currVal_1); }); }\nfunction View_HomeComponent_4(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 3, \"div\", [[\"class\", \"no-image\"]], null, null, null, null, null)), (_l()(), i1.ɵeld(1, 0, null, null, 2, \"mat-icon\", [[\"class\", \"mat-icon notranslate\"], [\"role\", \"img\"]], [[2, \"mat-icon-inline\", null], [2, \"mat-icon-no-color\", null]], null, null, i2.View_MatIcon_0, i2.RenderType_MatIcon)), i1.ɵdid(2, 9158656, null, 0, i3.MatIcon, [i1.ElementRef, i3.MatIconRegistry, [8, null], [2, i3.MAT_ICON_LOCATION]], null, null), (_l()(), i1.ɵted(3, 0, [\"\", \"\"]))], function (_ck, _v) { _ck(_v, 2, 0); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = i1.ɵnov(_v, 2).inline; var currVal_1 = (((i1.ɵnov(_v, 2).color !== \"primary\") && (i1.ɵnov(_v, 2).color !== \"accent\")) && (i1.ɵnov(_v, 2).color !== \"warn\")); _ck(_v, 1, 0, currVal_0, currVal_1); var currVal_2 = _co.viewIcon(_v.parent.context.$implicit.type); _ck(_v, 3, 0, currVal_2); }); }\nfunction View_HomeComponent_2(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 14, \"div\", [[\"class\", \"tile landscape\"]], null, null, null, null, null)), (_l()(), i1.ɵeld(1, 0, null, null, 13, \"a\", [], [[1, \"target\", 0], [8, \"href\", 4]], [[null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"click\" === en)) {\n        var pd_0 = (i1.ɵnov(_v, 2).onClick($event.button, $event.ctrlKey, $event.metaKey, $event.shiftKey) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i1.ɵdid(2, 671744, null, 0, i4.RouterLinkWithHref, [i4.Router, i4.ActivatedRoute, i5.LocationStrategy], { routerLink: [0, \"routerLink\"] }, null), (_l()(), i1.ɵeld(3, 0, null, null, 11, \"mat-card\", [[\"class\", \"mat-card mat-ripple\"], [\"mat-ripple\", \"\"]], [[2, \"_mat-animation-noopable\", null], [2, \"mat-ripple-unbounded\", null]], null, null, i6.View_MatCard_0, i6.RenderType_MatCard)), i1.ɵdid(4, 49152, null, 0, i7.MatCard, [[2, i8.ANIMATION_MODULE_TYPE]], null, null), i1.ɵdid(5, 212992, null, 0, i9.MatRipple, [i1.ElementRef, i1.NgZone, i10.Platform, [2, i9.MAT_RIPPLE_GLOBAL_OPTIONS], [2, i8.ANIMATION_MODULE_TYPE]], null, null), (_l()(), i1.ɵeld(6, 0, null, 0, 5, \"div\", [[\"class\", \"mat-card-image\"], [\"mat-card-image\", \"\"]], null, null, null, null, null)), i1.ɵdid(7, 16384, null, 0, i7.MatCardImage, [], null, null), (_l()(), i1.ɵand(16777216, null, null, 1, null, View_HomeComponent_3)), i1.ɵdid(9, 16384, null, 0, i5.NgIf, [i1.ViewContainerRef, i1.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i1.ɵand(16777216, null, null, 1, null, View_HomeComponent_4)), i1.ɵdid(11, 16384, null, 0, i5.NgIf, [i1.ViewContainerRef, i1.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i1.ɵeld(12, 0, null, 0, 2, \"mat-card-subtitle\", [[\"class\", \"mat-card-subtitle\"]], null, null, null, null, null)), i1.ɵdid(13, 16384, null, 0, i7.MatCardSubtitle, [], null, null), (_l()(), i1.ɵted(14, null, [\" \", \" \"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _co.viewUrl(_v.context.$implicit.type).toString(); _ck(_v, 2, 0, currVal_2); _ck(_v, 5, 0); var currVal_5 = _v.context.$implicit.image; _ck(_v, 9, 0, currVal_5); var currVal_6 = !_v.context.$implicit.image; _ck(_v, 11, 0, currVal_6); }, function (_ck, _v) { var currVal_0 = i1.ɵnov(_v, 2).target; var currVal_1 = i1.ɵnov(_v, 2).href; _ck(_v, 1, 0, currVal_0, currVal_1); var currVal_3 = (i1.ɵnov(_v, 4)._animationMode === \"NoopAnimations\"); var currVal_4 = i1.ɵnov(_v, 5).unbounded; _ck(_v, 3, 0, currVal_3, currVal_4); var currVal_7 = _v.context.$implicit.subtitle; _ck(_v, 14, 0, currVal_7); }); }\nfunction View_HomeComponent_6(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 0, \"img\", [[\"class\", \"inner-img\"]], [[8, \"src\", 4], [8, \"alt\", 0]], [[null, \"dragstart\"]], function (_v, en, $event) { var ad = true; if ((\"dragstart\" === en)) {\n        var pd_0 = ($event.preventDefault() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.$implicit.image; var currVal_1 = _v.parent.context.$implicit.subtitle; _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_HomeComponent_7(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 1, \"div\", [[\"class\", \"year\"]], null, null, null, null, null)), (_l()(), i1.ɵted(1, null, [\" \", \" \"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.$implicit.year; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_HomeComponent_5(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 16, \"div\", [[\"class\", \"tile landscape\"]], null, null, null, null, null)), (_l()(), i1.ɵeld(1, 16777216, null, null, 15, \"mat-card\", [[\"aria-label\", \"movie.originalTitle\"], [\"class\", \"mat-card mat-ripple\"], [\"mat-ripple\", \"\"], [\"matTooltipPosition\", \"below\"]], [[2, \"_mat-animation-noopable\", null], [2, \"mat-ripple-unbounded\", null]], [[null, \"longpress\"], [null, \"keydown\"], [null, \"touchend\"]], function (_v, en, $event) { var ad = true; if ((\"longpress\" === en)) {\n        var pd_0 = (i1.ɵnov(_v, 4).show() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"keydown\" === en)) {\n        var pd_1 = (i1.ɵnov(_v, 4)._handleKeydown($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"touchend\" === en)) {\n        var pd_2 = (i1.ɵnov(_v, 4)._handleTouchend() !== false);\n        ad = (pd_2 && ad);\n    } return ad; }, i6.View_MatCard_0, i6.RenderType_MatCard)), i1.ɵdid(2, 49152, null, 0, i7.MatCard, [[2, i8.ANIMATION_MODULE_TYPE]], null, null), i1.ɵdid(3, 212992, null, 0, i9.MatRipple, [i1.ElementRef, i1.NgZone, i10.Platform, [2, i9.MAT_RIPPLE_GLOBAL_OPTIONS], [2, i8.ANIMATION_MODULE_TYPE]], null, null), i1.ɵdid(4, 212992, null, 0, i11.MatTooltip, [i12.Overlay, i1.ElementRef, i13.ScrollDispatcher, i1.ViewContainerRef, i1.NgZone, i10.Platform, i14.AriaDescriber, i14.FocusMonitor, i11.MAT_TOOLTIP_SCROLL_STRATEGY, [2, i15.Directionality], [2, i11.MAT_TOOLTIP_DEFAULT_OPTIONS], [2, i16.HAMMER_LOADER]], { position: [0, \"position\"], message: [1, \"message\"] }, null), (_l()(), i1.ɵeld(5, 0, null, 0, 6, \"div\", [[\"class\", \"mat-card-image\"], [\"mat-card-image\", \"\"]], null, null, null, null, null)), i1.ɵdid(6, 16384, null, 0, i7.MatCardImage, [], null, null), (_l()(), i1.ɵeld(7, 0, null, null, 4, \"div\", [[\"class\", \"img-wrapper\"]], null, null, null, null, null)), (_l()(), i1.ɵand(16777216, null, null, 1, null, View_HomeComponent_6)), i1.ɵdid(9, 16384, null, 0, i5.NgIf, [i1.ViewContainerRef, i1.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i1.ɵeld(10, 0, null, null, 1, \"mat-progress-bar\", [[\"aria-valuemax\", \"100\"], [\"aria-valuemin\", \"0\"], [\"class\", \"mat-progress-bar\"], [\"color\", \"accent\"], [\"role\", \"progressbar\"]], [[1, \"aria-valuenow\", 0], [1, \"mode\", 0], [2, \"_mat-animation-noopable\", null]], null, null, i17.View_MatProgressBar_0, i17.RenderType_MatProgressBar)), i1.ɵdid(11, 4374528, null, 0, i18.MatProgressBar, [i1.ElementRef, i1.NgZone, [2, i8.ANIMATION_MODULE_TYPE], [2, i18.MAT_PROGRESS_BAR_LOCATION]], { color: [0, \"color\"], value: [1, \"value\"] }, null), (_l()(), i1.ɵeld(12, 0, null, 0, 4, \"mat-card-subtitle\", [[\"class\", \"mat-card-subtitle\"]], null, null, null, null, null)), i1.ɵdid(13, 16384, null, 0, i7.MatCardSubtitle, [], null, null), (_l()(), i1.ɵted(14, null, [\" \", \" \"])), (_l()(), i1.ɵand(16777216, null, null, 1, null, View_HomeComponent_7)), i1.ɵdid(16, 16384, null, 0, i5.NgIf, [i1.ViewContainerRef, i1.TemplateRef], { ngIf: [0, \"ngIf\"] }, null)], function (_ck, _v) { _ck(_v, 3, 0); var currVal_2 = \"below\"; var currVal_3 = _v.context.$implicit.originalTitle; _ck(_v, 4, 0, currVal_2, currVal_3); var currVal_4 = _v.context.$implicit.image; _ck(_v, 9, 0, currVal_4); var currVal_8 = \"accent\"; var currVal_9 = _v.context.$implicit.progress; _ck(_v, 11, 0, currVal_8, currVal_9); var currVal_11 = _v.context.$implicit.year; _ck(_v, 16, 0, currVal_11); }, function (_ck, _v) { var currVal_0 = (i1.ɵnov(_v, 2)._animationMode === \"NoopAnimations\"); var currVal_1 = i1.ɵnov(_v, 3).unbounded; _ck(_v, 1, 0, currVal_0, currVal_1); var currVal_5 = (((i1.ɵnov(_v, 11).mode === \"indeterminate\") || (i1.ɵnov(_v, 11).mode === \"query\")) ? null : i1.ɵnov(_v, 11).value); var currVal_6 = i1.ɵnov(_v, 11).mode; var currVal_7 = i1.ɵnov(_v, 11)._isNoopAnimation; _ck(_v, 10, 0, currVal_5, currVal_6, currVal_7); var currVal_10 = _v.context.$implicit.subtitle; _ck(_v, 14, 0, currVal_10); }); }\nfunction View_HomeComponent_9(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 0, \"img\", [[\"class\", \"inner-img\"]], [[8, \"src\", 4], [8, \"alt\", 0]], [[null, \"dragstart\"]], function (_v, en, $event) { var ad = true; if ((\"dragstart\" === en)) {\n        var pd_0 = ($event.preventDefault() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.$implicit.image; var currVal_1 = _v.parent.context.$implicit.subtitle; _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_HomeComponent_10(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 1, \"div\", [[\"class\", \"year\"]], null, null, null, null, null)), (_l()(), i1.ɵted(1, null, [\" \", \" \"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.$implicit.year; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_HomeComponent_8(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 13, \"div\", [[\"class\", \"tile portrait\"]], null, null, null, null, null)), (_l()(), i1.ɵeld(1, 16777216, null, null, 12, \"mat-card\", [[\"aria-label\", \"movie.originalTitle\"], [\"class\", \"mat-card mat-ripple\"], [\"mat-ripple\", \"\"], [\"matTooltipPosition\", \"below\"]], [[2, \"_mat-animation-noopable\", null], [2, \"mat-ripple-unbounded\", null]], [[null, \"longpress\"], [null, \"keydown\"], [null, \"touchend\"]], function (_v, en, $event) { var ad = true; if ((\"longpress\" === en)) {\n        var pd_0 = (i1.ɵnov(_v, 4).show() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"keydown\" === en)) {\n        var pd_1 = (i1.ɵnov(_v, 4)._handleKeydown($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"touchend\" === en)) {\n        var pd_2 = (i1.ɵnov(_v, 4)._handleTouchend() !== false);\n        ad = (pd_2 && ad);\n    } return ad; }, i6.View_MatCard_0, i6.RenderType_MatCard)), i1.ɵdid(2, 49152, null, 0, i7.MatCard, [[2, i8.ANIMATION_MODULE_TYPE]], null, null), i1.ɵdid(3, 212992, null, 0, i9.MatRipple, [i1.ElementRef, i1.NgZone, i10.Platform, [2, i9.MAT_RIPPLE_GLOBAL_OPTIONS], [2, i8.ANIMATION_MODULE_TYPE]], null, null), i1.ɵdid(4, 212992, null, 0, i11.MatTooltip, [i12.Overlay, i1.ElementRef, i13.ScrollDispatcher, i1.ViewContainerRef, i1.NgZone, i10.Platform, i14.AriaDescriber, i14.FocusMonitor, i11.MAT_TOOLTIP_SCROLL_STRATEGY, [2, i15.Directionality], [2, i11.MAT_TOOLTIP_DEFAULT_OPTIONS], [2, i16.HAMMER_LOADER]], { position: [0, \"position\"], message: [1, \"message\"] }, null), (_l()(), i1.ɵeld(5, 0, null, 0, 3, \"div\", [[\"class\", \"mat-card-image\"], [\"mat-card-image\", \"\"]], null, null, null, null, null)), i1.ɵdid(6, 16384, null, 0, i7.MatCardImage, [], null, null), (_l()(), i1.ɵand(16777216, null, null, 1, null, View_HomeComponent_9)), i1.ɵdid(8, 16384, null, 0, i5.NgIf, [i1.ViewContainerRef, i1.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i1.ɵeld(9, 0, null, 0, 4, \"mat-card-subtitle\", [[\"class\", \"mat-card-subtitle\"]], null, null, null, null, null)), i1.ɵdid(10, 16384, null, 0, i7.MatCardSubtitle, [], null, null), (_l()(), i1.ɵted(11, null, [\" \", \" \"])), (_l()(), i1.ɵand(16777216, null, null, 1, null, View_HomeComponent_10)), i1.ɵdid(13, 16384, null, 0, i5.NgIf, [i1.ViewContainerRef, i1.TemplateRef], { ngIf: [0, \"ngIf\"] }, null)], function (_ck, _v) { _ck(_v, 3, 0); var currVal_2 = \"below\"; var currVal_3 = _v.context.$implicit.originalTitle; _ck(_v, 4, 0, currVal_2, currVal_3); var currVal_4 = _v.context.$implicit.image; _ck(_v, 8, 0, currVal_4); var currVal_6 = _v.context.$implicit.year; _ck(_v, 13, 0, currVal_6); }, function (_ck, _v) { var currVal_0 = (i1.ɵnov(_v, 2)._animationMode === \"NoopAnimations\"); var currVal_1 = i1.ɵnov(_v, 3).unbounded; _ck(_v, 1, 0, currVal_0, currVal_1); var currVal_5 = _v.context.$implicit.subtitle; _ck(_v, 11, 0, currVal_5); }); }\nfunction View_HomeComponent_1(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 21, null, null, null, null, null, null, null)), (_l()(), i1.ɵeld(1, 0, null, null, 6, \"section\", [], null, null, null, null, null)), (_l()(), i1.ɵeld(2, 0, null, null, 1, \"h2\", [], null, null, null, null, null)), (_l()(), i1.ɵted(-1, null, [\"My Media\"])), (_l()(), i1.ɵeld(4, 0, null, null, 3, \"jellyfin-slider\", [], null, null, null, i19.View_SliderComponent_0, i19.RenderType_SliderComponent)), i1.ɵdid(5, 1097728, null, 0, i20.SliderComponent, [i1.ChangeDetectorRef], null, null), (_l()(), i1.ɵand(16777216, null, 0, 1, null, View_HomeComponent_2)), i1.ɵdid(7, 278528, null, 0, i5.NgForOf, [i1.ViewContainerRef, i1.TemplateRef, i1.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i1.ɵeld(8, 0, null, null, 6, \"section\", [], null, null, null, null, null)), (_l()(), i1.ɵeld(9, 0, null, null, 1, \"h2\", [], null, null, null, null, null)), (_l()(), i1.ɵted(-1, null, [\"Continue watching\"])), (_l()(), i1.ɵeld(11, 0, null, null, 3, \"jellyfin-slider\", [], null, null, null, i19.View_SliderComponent_0, i19.RenderType_SliderComponent)), i1.ɵdid(12, 1097728, null, 0, i20.SliderComponent, [i1.ChangeDetectorRef], null, null), (_l()(), i1.ɵand(16777216, null, 0, 1, null, View_HomeComponent_5)), i1.ɵdid(14, 278528, null, 0, i5.NgForOf, [i1.ViewContainerRef, i1.TemplateRef, i1.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i1.ɵeld(15, 0, null, null, 6, \"section\", [], null, null, null, null, null)), (_l()(), i1.ɵeld(16, 0, null, null, 1, \"h2\", [], null, null, null, null, null)), (_l()(), i1.ɵted(-1, null, [\"Latest movies\"])), (_l()(), i1.ɵeld(18, 0, null, null, 3, \"jellyfin-slider\", [], null, null, null, i19.View_SliderComponent_0, i19.RenderType_SliderComponent)), i1.ɵdid(19, 1097728, null, 0, i20.SliderComponent, [i1.ChangeDetectorRef], null, null), (_l()(), i1.ɵand(16777216, null, 0, 1, null, View_HomeComponent_8)), i1.ɵdid(21, 278528, null, 0, i5.NgForOf, [i1.ViewContainerRef, i1.TemplateRef, i1.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.myMedia; _ck(_v, 7, 0, currVal_0); var currVal_1 = _co.continueWatching; _ck(_v, 14, 0, currVal_1); var currVal_2 = _co.latestMovies; _ck(_v, 21, 0, currVal_2); }, null); }\nfunction View_HomeComponent_11(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 1, \"mat-spinner\", [[\"class\", \"mat-spinner mat-progress-spinner\"], [\"mode\", \"indeterminate\"], [\"role\", \"progressbar\"]], [[2, \"_mat-animation-noopable\", null], [4, \"width\", \"px\"], [4, \"height\", \"px\"]], null, null, i21.View_MatSpinner_0, i21.RenderType_MatSpinner)), i1.ɵdid(1, 114688, null, 0, i22.MatSpinner, [i1.ElementRef, i10.Platform, [2, i5.DOCUMENT], [2, i8.ANIMATION_MODULE_TYPE], i22.MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, function (_ck, _v) { var currVal_0 = i1.ɵnov(_v, 1)._noopAnimations; var currVal_1 = i1.ɵnov(_v, 1).diameter; var currVal_2 = i1.ɵnov(_v, 1).diameter; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2); }); }\nexport function View_HomeComponent_0(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵand(16777216, null, null, 1, null, View_HomeComponent_1)), i1.ɵdid(1, 16384, null, 0, i5.NgIf, [i1.ViewContainerRef, i1.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i1.ɵand(16777216, null, null, 1, null, View_HomeComponent_11)), i1.ɵdid(3, 16384, null, 0, i5.NgIf, [i1.ViewContainerRef, i1.TemplateRef], { ngIf: [0, \"ngIf\"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.loaded; _ck(_v, 1, 0, currVal_0); var currVal_1 = !_co.loaded; _ck(_v, 3, 0, currVal_1); }, null); }\nexport function View_HomeComponent_Host_0(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 1, \"jellyfin-home\", [], null, null, null, View_HomeComponent_0, RenderType_HomeComponent)), i1.ɵdid(1, 114688, null, 0, i23.HomeComponent, [i24.ApiService, i25.AuthService, i4.Router], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar HomeComponentNgFactory = i1.ɵccf(\"jellyfin-home\", i23.HomeComponent, View_HomeComponent_Host_0, {}, {}, []);\nexport { HomeComponentNgFactory as HomeComponentNgFactory };\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nvar styles = [\"[_nghost-%COMP%]{width:100%;min-height:100%;box-sizing:border-box;padding:5vmin;display:flex;flex-direction:column}.tile[_ngcontent-%COMP%]{padding:.5rem}.tile[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{text-decoration:none;outline:0}.tile.landscape[_ngcontent-%COMP%]   .img-wrapper[_ngcontent-%COMP%]{margin:0 auto}.tile.landscape[_ngcontent-%COMP%]   .img-wrapper[_ngcontent-%COMP%]   mat-progress-bar[_ngcontent-%COMP%]{margin-top:-5px}.tile.landscape[_ngcontent-%COMP%]   .inner-img[_ngcontent-%COMP%]{height:9rem}.tile.landscape[_ngcontent-%COMP%]   .no-image[_ngcontent-%COMP%]{height:9rem;min-width:16rem;flex-grow:1;display:flex}.tile.landscape[_ngcontent-%COMP%]   .no-image[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{margin:auto}.tile.portrait[_ngcontent-%COMP%]{width:9rem;min-width:9rem}mat-card[_ngcontent-%COMP%]{cursor:pointer;display:flex;flex-direction:column;height:calc(100% - 2rem)}mat-card[_ngcontent-%COMP%]   mat-card-subtitle[_ngcontent-%COMP%]{color:#fff;text-align:center;margin-top:16px;margin-bottom:-4px!important;overflow-wrap:break-word;overflow-wrap:anywhere;-webkit-hyphens:auto;hyphens:auto}mat-card[_ngcontent-%COMP%]   mat-card-subtitle[_ngcontent-%COMP%]   .year[_ngcontent-%COMP%]{color:#b9b9b9}mat-card[_ngcontent-%COMP%]   .inner-img[_ngcontent-%COMP%]{margin-bottom:auto;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:100%}mat-card[_ngcontent-%COMP%]   .mat-card-image[_ngcontent-%COMP%]{margin-bottom:0;flex-grow:1;display:flex}mat-spinner[_ngcontent-%COMP%]{margin:auto}\"];\nexport { styles as styles };\n","<ng-container *ngIf=\"loaded\">\n    <section>\n        <h2>My Media</h2>\n        <jellyfin-slider>\n            <div class=\"tile landscape\" *ngFor=\"let view of myMedia\">\n                <a [routerLink]=\"viewUrl(view.type).toString()\">\n                    <mat-card mat-ripple>\n                        <div mat-card-image>\n                            <div class=\"img-wrapper\" *ngIf=\"view.image\">\n                                <img\n                                    class=\"inner-img\"\n                                    [src]=\"view.image\"\n                                    [alt]=\"view.subtitle\"\n                                    (dragstart)=\"$event.preventDefault()\"\n                                />\n                            </div>\n                            <div class=\"no-image\" *ngIf=\"!view.image\">\n                                <mat-icon>{{ viewIcon(view.type) }}</mat-icon>\n                            </div>\n                        </div>\n                        <mat-card-subtitle>\n                            {{ view.subtitle }}\n                        </mat-card-subtitle>\n                    </mat-card>\n                </a>\n            </div>\n        </jellyfin-slider>\n    </section>\n    <section>\n        <h2>Continue watching</h2>\n        <jellyfin-slider>\n            <div class=\"tile landscape\" *ngFor=\"let movie of continueWatching\">\n                <mat-card\n                    mat-ripple\n                    [matTooltip]=\"movie.originalTitle\"\n                    matTooltipPosition=\"below\"\n                    aria-label=\"movie.originalTitle\"\n                >\n                    <div mat-card-image>\n                        <div class=\"img-wrapper\">\n                            <img\n                                *ngIf=\"movie.image\"\n                                class=\"inner-img\"\n                                [src]=\"movie.image\"\n                                [alt]=\"movie.subtitle\"\n                                (dragstart)=\"$event.preventDefault()\"\n                            />\n                            <mat-progress-bar\n                                [value]=\"movie.progress\"\n                                color=\"accent\"\n                            ></mat-progress-bar>\n                        </div>\n                    </div>\n                    <mat-card-subtitle>\n                        {{ movie.subtitle }}\n                        <div *ngIf=\"movie.year\" class=\"year\">\n                            {{ movie.year }}\n                        </div>\n                    </mat-card-subtitle>\n                </mat-card>\n            </div>\n        </jellyfin-slider>\n    </section>\n    <section>\n        <h2>Latest movies</h2>\n        <jellyfin-slider>\n            <div class=\"tile portrait\" *ngFor=\"let movie of latestMovies\">\n                <mat-card\n                    mat-ripple\n                    [matTooltip]=\"movie.originalTitle\"\n                    matTooltipPosition=\"below\"\n                    aria-label=\"movie.originalTitle\"\n                >\n                    <div mat-card-image>\n                        <img\n                            *ngIf=\"movie.image\"\n                            class=\"inner-img\"\n                            [src]=\"movie.image\"\n                            [alt]=\"movie.subtitle\"\n                            (dragstart)=\"$event.preventDefault()\"\n                        />\n                    </div>\n                    <mat-card-subtitle>\n                        {{ movie.subtitle }}\n                        <div *ngIf=\"movie.year\" class=\"year\">\n                            {{ movie.year }}\n                        </div>\n                    </mat-card-subtitle>\n                </mat-card>\n            </div>\n        </jellyfin-slider>\n    </section>\n</ng-container>\n<mat-spinner *ngIf=\"!loaded\"></mat-spinner>\n","import { Component, OnInit } from \"@angular/core\";\n\n@Component({\n    selector: \"jellyfin-movies\",\n    templateUrl: \"./movies.component.html\",\n    styleUrls: [\"./movies.component.scss\"]\n})\nexport class MoviesComponent implements OnInit {\n    constructor() {}\n\n    public ngOnInit() {}\n}\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"./movies.component.scss.shim.ngstyle\";\nimport * as i1 from \"@angular/core\";\nimport * as i2 from \"./movies.component\";\nvar styles_MoviesComponent = [i0.styles];\nvar RenderType_MoviesComponent = i1.ɵcrt({ encapsulation: 0, styles: styles_MoviesComponent, data: {} });\nexport { RenderType_MoviesComponent as RenderType_MoviesComponent };\nexport function View_MoviesComponent_0(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 1, \"p\", [], null, null, null, null, null)), (_l()(), i1.ɵted(-1, null, [\"movies works!\"]))], null, null); }\nexport function View_MoviesComponent_Host_0(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 1, \"jellyfin-movies\", [], null, null, null, View_MoviesComponent_0, RenderType_MoviesComponent)), i1.ɵdid(1, 114688, null, 0, i2.MoviesComponent, [], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar MoviesComponentNgFactory = i1.ɵccf(\"jellyfin-movies\", i2.MoviesComponent, View_MoviesComponent_Host_0, {}, {}, []);\nexport { MoviesComponentNgFactory as MoviesComponentNgFactory };\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nvar styles = [\"\"];\nexport { styles as styles };\n","<p>movies works!</p>\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/material/tooltip\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"@angular/cdk/observers\";\nimport * as i4 from \"@angular/cdk/overlay\";\nimport * as i5 from \"@angular/cdk/bidi\";\nimport * as i6 from \"@angular/platform-browser\";\nimport * as i7 from \"@angular/material/core\";\nimport * as i8 from \"@angular/cdk/platform\";\nimport * as i9 from \"@angular/cdk/a11y\";\nimport * as i10 from \"@angular/cdk/portal\";\nimport * as i11 from \"@angular/cdk/scrolling\";\nimport * as i12 from \"@angular/cdk/layout\";\nvar MatTooltipModuleNgFactory = i0.ɵcmf(i1.MatTooltipModule, [], function (_l) { return i0.ɵmod([i0.ɵmpd(512, i0.ComponentFactoryResolver, i0.ɵCodegenComponentFactoryResolver, [[8, [TooltipComponentNgFactory]], [3, i0.ComponentFactoryResolver], i0.NgModuleRef]), i0.ɵmpd(4608, i2.NgLocalization, i2.NgLocaleLocalization, [i0.LOCALE_ID, [2, i2.ɵangular_packages_common_common_a]]), i0.ɵmpd(4608, i3.MutationObserverFactory, i3.MutationObserverFactory, []), i0.ɵmpd(4608, i4.Overlay, i4.Overlay, [i4.ScrollStrategyOptions, i4.OverlayContainer, i0.ComponentFactoryResolver, i4.OverlayPositionBuilder, i4.OverlayKeyboardDispatcher, i0.Injector, i0.NgZone, i2.DOCUMENT, i5.Directionality, [2, i2.Location]]), i0.ɵmpd(5120, i4.ɵc, i4.ɵd, [i4.Overlay]), i0.ɵmpd(5120, i1.MAT_TOOLTIP_SCROLL_STRATEGY, i1.MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY, [i4.Overlay]), i0.ɵmpd(4608, i6.HAMMER_GESTURE_CONFIG, i7.GestureConfig, [[2, i7.MAT_HAMMER_OPTIONS], [2, i7.MatCommonModule]]), i0.ɵmpd(1073742336, i2.CommonModule, i2.CommonModule, []), i0.ɵmpd(1073742336, i8.PlatformModule, i8.PlatformModule, []), i0.ɵmpd(1073742336, i3.ObserversModule, i3.ObserversModule, []), i0.ɵmpd(1073742336, i9.A11yModule, i9.A11yModule, []), i0.ɵmpd(1073742336, i5.BidiModule, i5.BidiModule, []), i0.ɵmpd(1073742336, i10.PortalModule, i10.PortalModule, []), i0.ɵmpd(1073742336, i11.ScrollingModule, i11.ScrollingModule, []), i0.ɵmpd(1073742336, i4.OverlayModule, i4.OverlayModule, []), i0.ɵmpd(1073742336, i7.MatCommonModule, i7.MatCommonModule, [[2, i7.MATERIAL_SANITY_CHECKS], [2, i6.HAMMER_LOADER]]), i0.ɵmpd(1073742336, i1.MatTooltipModule, i1.MatTooltipModule, [])]); });\nexport { MatTooltipModuleNgFactory as MatTooltipModuleNgFactory };\nvar styles_TooltipComponent = [\".mat-tooltip-panel{pointer-events:none!important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}@media (-ms-high-contrast:active){.mat-tooltip{outline:solid 1px}}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\"];\nvar RenderType_TooltipComponent = i0.ɵcrt({ encapsulation: 2, styles: styles_TooltipComponent, data: { \"animation\": [{ type: 7, name: \"state\", definitions: [{ type: 0, name: \"initial, void, hidden\", styles: { type: 6, styles: { opacity: 0, transform: \"scale(0)\" }, offset: null }, options: undefined }, { type: 0, name: \"visible\", styles: { type: 6, styles: { transform: \"scale(1)\" }, offset: null }, options: undefined }, { type: 1, expr: \"* => visible\", animation: { type: 4, styles: { type: 5, steps: [{ type: 6, styles: { opacity: 0, transform: \"scale(0)\", offset: 0 }, offset: null }, { type: 6, styles: { opacity: 0.5, transform: \"scale(0.99)\", offset: 0.5 }, offset: null }, { type: 6, styles: { opacity: 1, transform: \"scale(1)\", offset: 1 }, offset: null }] }, timings: \"200ms cubic-bezier(0, 0, 0.2, 1)\" }, options: null }, { type: 1, expr: \"* => hidden\", animation: { type: 4, styles: { type: 6, styles: { opacity: 0 }, offset: null }, timings: \"100ms cubic-bezier(0, 0, 0.2, 1)\" }, options: null }], options: {} }] } });\nexport { RenderType_TooltipComponent as RenderType_TooltipComponent };\nexport function View_TooltipComponent_0(_l) { return i0.ɵvid(2, [(_l()(), i0.ɵeld(0, 0, null, null, 4, \"div\", [[\"class\", \"mat-tooltip\"]], [[2, \"mat-tooltip-handset\", null], [24, \"@state\", 0]], [[null, \"@state.start\"], [null, \"@state.done\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"@state.start\" === en)) {\n        var pd_0 = (_co._animationStart() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"@state.done\" === en)) {\n        var pd_1 = (_co._animationDone($event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), i0.ɵprd(512, null, i2.ɵNgClassImpl, i2.ɵNgClassR2Impl, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2]), i0.ɵdid(2, 278528, null, 0, i2.NgClass, [i2.ɵNgClassImpl], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.ɵpid(131072, i2.AsyncPipe, [i0.ChangeDetectorRef]), (_l()(), i0.ɵted(4, null, [\"\", \"\"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = \"mat-tooltip\"; var currVal_3 = _co.tooltipClass; _ck(_v, 2, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var tmp_0_0 = null; var currVal_0 = (((tmp_0_0 = i0.ɵunv(_v, 0, 0, i0.ɵnov(_v, 3).transform(_co._isHandset))) == null) ? null : tmp_0_0.matches); var currVal_1 = _co._visibility; _ck(_v, 0, 0, currVal_0, currVal_1); var currVal_4 = _co.message; _ck(_v, 4, 0, currVal_4); }); }\nexport function View_TooltipComponent_Host_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"mat-tooltip-component\", [[\"aria-hidden\", \"true\"]], [[4, \"zoom\", null]], [[\"body\", \"click\"]], function (_v, en, $event) { var ad = true; if ((\"body:click\" === en)) {\n        var pd_0 = (i0.ɵnov(_v, 1)._handleBodyInteraction() !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, View_TooltipComponent_0, RenderType_TooltipComponent)), i0.ɵdid(1, 180224, null, 0, i1.TooltipComponent, [i0.ChangeDetectorRef, i12.BreakpointObserver], null, null)], null, function (_ck, _v) { var currVal_0 = ((i0.ɵnov(_v, 1)._visibility === \"visible\") ? 1 : null); _ck(_v, 0, 0, currVal_0); }); }\nvar TooltipComponentNgFactory = i0.ɵccf(\"mat-tooltip-component\", i1.TooltipComponent, View_TooltipComponent_Host_0, {}, {}, []);\nexport { TooltipComponentNgFactory as TooltipComponentNgFactory };\n","<div class=\"mat-tooltip\" [ngClass]=\"tooltipClass\" [class.mat-tooltip-handset]=\"(_isHandset | async)?.matches\" [@state]=\"_visibility\" (@state.start)=\"_animationStart()\" (@state.done)=\"_animationDone($event)\">{{message}}</div>","import { NgModule } from \"@angular/core\";\nimport { RouterModule, Routes } from \"@angular/router\";\nimport { HomeComponent } from \"../library/home/home.component\";\nimport { MoviesComponent } from \"../library/movies/movies.component\";\n\nconst routes: Routes = [\n    {\n        path: \"\",\n        component: HomeComponent\n    },\n    {\n        path: \"movies\",\n        component: MoviesComponent\n    }\n];\n\n@NgModule({\n    imports: [RouterModule.forChild(routes)],\n    exports: [RouterModule]\n})\nexport class ShellRoutingModule {}\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./shell.module\";\nimport * as i2 from \"../../../node_modules/@angular/router/router.ngfactory\";\nimport * as i3 from \"../library/home/home.component.ngfactory\";\nimport * as i4 from \"../library/movies/movies.component.ngfactory\";\nimport * as i5 from \"../../../node_modules/@angular/material/tooltip/typings/index.ngfactory\";\nimport * as i6 from \"@angular/common\";\nimport * as i7 from \"@angular/cdk/observers\";\nimport * as i8 from \"@angular/cdk/overlay\";\nimport * as i9 from \"@angular/cdk/bidi\";\nimport * as i10 from \"@angular/material/tooltip\";\nimport * as i11 from \"@angular/platform-browser\";\nimport * as i12 from \"@angular/material/core\";\nimport * as i13 from \"@angular/router\";\nimport * as i14 from \"./shell-routing.module\";\nimport * as i15 from \"@angular/material/card\";\nimport * as i16 from \"@angular/cdk/platform\";\nimport * as i17 from \"@angular/material/button\";\nimport * as i18 from \"@angular/material/progress-spinner\";\nimport * as i19 from \"ngx-infinite-scroll\";\nimport * as i20 from \"@angular/cdk/a11y\";\nimport * as i21 from \"@angular/cdk/portal\";\nimport * as i22 from \"@angular/cdk/scrolling\";\nimport * as i23 from \"@angular/material/progress-bar\";\nimport * as i24 from \"@angular/material/icon\";\nimport * as i25 from \"../library/home/home.component\";\nimport * as i26 from \"../library/movies/movies.component\";\nvar ShellModuleNgFactory = i0.ɵcmf(i1.ShellModule, [], function (_l) { return i0.ɵmod([i0.ɵmpd(512, i0.ComponentFactoryResolver, i0.ɵCodegenComponentFactoryResolver, [[8, [i2.ɵangular_packages_router_router_lNgFactory, i3.HomeComponentNgFactory, i4.MoviesComponentNgFactory, i5.TooltipComponentNgFactory]], [3, i0.ComponentFactoryResolver], i0.NgModuleRef]), i0.ɵmpd(4608, i6.NgLocalization, i6.NgLocaleLocalization, [i0.LOCALE_ID, [2, i6.ɵangular_packages_common_common_a]]), i0.ɵmpd(4608, i7.MutationObserverFactory, i7.MutationObserverFactory, []), i0.ɵmpd(4608, i8.Overlay, i8.Overlay, [i8.ScrollStrategyOptions, i8.OverlayContainer, i0.ComponentFactoryResolver, i8.OverlayPositionBuilder, i8.OverlayKeyboardDispatcher, i0.Injector, i0.NgZone, i6.DOCUMENT, i9.Directionality, [2, i6.Location]]), i0.ɵmpd(5120, i8.ɵc, i8.ɵd, [i8.Overlay]), i0.ɵmpd(5120, i10.MAT_TOOLTIP_SCROLL_STRATEGY, i10.MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY, [i8.Overlay]), i0.ɵmpd(4608, i11.HAMMER_GESTURE_CONFIG, i12.GestureConfig, [[2, i12.MAT_HAMMER_OPTIONS], [2, i12.MatCommonModule]]), i0.ɵmpd(1073742336, i6.CommonModule, i6.CommonModule, []), i0.ɵmpd(1073742336, i13.RouterModule, i13.RouterModule, [[2, i13.ɵangular_packages_router_router_a], [2, i13.Router]]), i0.ɵmpd(1073742336, i14.ShellRoutingModule, i14.ShellRoutingModule, []), i0.ɵmpd(1073742336, i9.BidiModule, i9.BidiModule, []), i0.ɵmpd(1073742336, i12.MatCommonModule, i12.MatCommonModule, [[2, i12.MATERIAL_SANITY_CHECKS], [2, i11.HAMMER_LOADER]]), i0.ɵmpd(1073742336, i15.MatCardModule, i15.MatCardModule, []), i0.ɵmpd(1073742336, i16.PlatformModule, i16.PlatformModule, []), i0.ɵmpd(1073742336, i12.MatRippleModule, i12.MatRippleModule, []), i0.ɵmpd(1073742336, i17.MatButtonModule, i17.MatButtonModule, []), i0.ɵmpd(1073742336, i18.MatProgressSpinnerModule, i18.MatProgressSpinnerModule, []), i0.ɵmpd(1073742336, i19.InfiniteScrollModule, i19.InfiniteScrollModule, []), i0.ɵmpd(1073742336, i7.ObserversModule, i7.ObserversModule, []), i0.ɵmpd(1073742336, i20.A11yModule, i20.A11yModule, []), i0.ɵmpd(1073742336, i21.PortalModule, i21.PortalModule, []), i0.ɵmpd(1073742336, i22.ScrollingModule, i22.ScrollingModule, []), i0.ɵmpd(1073742336, i8.OverlayModule, i8.OverlayModule, []), i0.ɵmpd(1073742336, i10.MatTooltipModule, i10.MatTooltipModule, []), i0.ɵmpd(1073742336, i23.MatProgressBarModule, i23.MatProgressBarModule, []), i0.ɵmpd(1073742336, i24.MatIconModule, i24.MatIconModule, []), i0.ɵmpd(1073742336, i1.ShellModule, i1.ShellModule, []), i0.ɵmpd(1024, i13.ROUTES, function () { return [[{ path: \"\", component: i25.HomeComponent }, { path: \"movies\", component: i26.MoviesComponent }]]; }, [])]); });\nexport { ShellModuleNgFactory as ShellModuleNgFactory };\n"],"sourceRoot":"webpack:///"}